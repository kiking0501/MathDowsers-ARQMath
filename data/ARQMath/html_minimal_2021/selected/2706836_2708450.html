<!DOCTYPE html>

<html>
<head>
<title>"Recursive definitions" in Tao's Analysis Vol I</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> "Recursive definitions" in Tao's Analysis Vol I </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="2706836">
<p>I am totally confused when Tao gets into recursive definitions (page 26).</p> <p>Paraphrasing, the axioms of natural numbers let us define sequences recursively. Suppose we want to build a sequence <span class="math-container" id="24985317" visual_id="79336"><math alttext="a_{0},a_{1},a_{2},..." class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi></mrow></semantics></math></span> by first defining <span class="math-container" id="24985318" visual_id="7155622"><math alttext="a_{0}:=c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>:=</mo><mi>c</mi></mrow></semantics></math></span> and then letting <span class="math-container" id="24985319" visual_id="7196298"><math alttext="a_{1}:=f_{0}(a_{0})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>:=</mo><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, then <span class="math-container" id="24985320" visual_id="7196299"><math alttext="a_{2}:=f_{1}(a_{1})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>:=</mo><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, etc. In general <span class="math-container" id="24985321" visual_id="4937524"><math alttext="a_{n++}:=f_{n}(a_{n})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mrow><mi>n</mi><mo>+</mo></mrow><mo>⁣</mo><mo>+</mo></mrow></msub><mo>:=</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. Now he claims that this procedure gives a single value to the sequence element <span class="math-container" id="24985322" visual_id="2733"><math alttext="a_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>n</mi></msub></semantics></math></span>, i.e. there is a unique function <span class="math-container" id="24985323" visual_id="43646"><math alttext="a(n)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> from <span class="math-container" id="24985324" visual_id="320"><math alttext="N" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi></semantics></math></span> to <span class="math-container" id="24985325" visual_id="320"><math alttext="N" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi></semantics></math></span> such that <span class="math-container" id="24985326" visual_id="314088"><math alttext="a(0)=c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>a</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>c</mi></mrow></semantics></math></span> and <span class="math-container" id="24985327" visual_id="7196300"><math alttext="a(n\text{++})=f_{n}(a(n))" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>a</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>⁢</mo><mtext>++</mtext></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> for each natural number <span class="math-container" id="24985328" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>.</p> <p>Proof: Induction. <span class="math-container" id="24985329" visual_id="7155622"><math alttext="a_{0}:=c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>:=</mo><mi>c</mi></mrow></semantics></math></span> as a base case (which does not get redefined by anything else since <span class="math-container" id="24985330" visual_id="7196301"><math alttext="n\text{++}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>⁢</mo><mtext>++</mtext></mrow></semantics></math></span> cannot be <span class="math-container" id="24985331" visual_id="2775866"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span> by Peano's third axiom). Then suppose inductively the procedure gives a single value to <span class="math-container" id="24985332" visual_id="2733"><math alttext="a_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>n</mi></msub></semantics></math></span>. Then it gives a single value to <span class="math-container" id="24985333" visual_id="4937524"><math alttext="a_{n++}:=f_{n}(a_{n})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mrow><mi>n</mi><mo>+</mo></mrow><mo>⁣</mo><mo>+</mo></mrow></msub><mo>:=</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, which does not get redefined anywhere due to the successor function being injective. This completes the induction and so <span class="math-container" id="24985334" visual_id="2733"><math alttext="a_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>n</mi></msub></semantics></math></span> is defined for each natural number <span class="math-container" id="24985335" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> with a single value assigned to each <span class="math-container" id="24985336" visual_id="2733"><math alttext="a_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>n</mi></msub></semantics></math></span>.</p> <p>Now, I have no idea what's going on here. I've read this at least ten times and I'm just not seeing it.</p> <p>I don't understand what he's doing here, what he's proving, what he's using this for, etc. He explains this definition right before we move forward into the definitions and derivations for things like addition: <span class="math-container" id="24985337" visual_id="1184248"><math alttext="0+m=m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mn>0</mn><mo>+</mo><mi>m</mi></mrow><mo>=</mo><mi>m</mi></mrow></semantics></math></span> and <span class="math-container" id="24985338" visual_id="7196302"><math alttext="(n\text{++})+m=(n+m)\text{++}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>⁢</mo><mtext>++</mtext></mrow><mo stretchy="false">)</mo></mrow><mo>+</mo><mi>m</mi></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mtext>++</mtext></mrow></mrow></semantics></math></span>.</p> <p>I don't understand why we have basically <span class="math-container" id="24985339" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> different functions denoted <span class="math-container" id="24985340" visual_id="6121703"><math alttext="f_{n}()" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>. Why not just <span class="math-container" id="24985341" visual_id="30908"><math alttext="f()" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>? What is this function supposed to do? What does this have to do with recursion? What is this allowing us to do?</p> <p>Tao sort of pulls this recursive paragraph out of nowhere and I don't understand what he's connecting this to or how it works or why we need it.</p> <p>For example, if we let <span class="math-container" id="24985342" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> represent the successor function, then addition is defined as <span class="math-container" id="24985343" visual_id="488951"><math alttext="m+0=m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>m</mi><mo>+</mo><mn>0</mn></mrow><mo>=</mo><mi>m</mi></mrow></semantics></math></span> with <span class="math-container" id="24985344" visual_id="488952"><math alttext="m+S(n)=S(m+n)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>m</mi><mo>+</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. How would this functional, recursive relationship map between this and what Tao is talking about? What is <span class="math-container" id="24985345" visual_id="7196303"><math alttext="a_{n\text{++}}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mrow><mi>n</mi><mo>⁢</mo><mtext>++</mtext></mrow></msub></semantics></math></span>? What is <span class="math-container" id="24985346" visual_id="1704356"><math alttext="f_{n}(a_{n})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>? And why not <span class="math-container" id="24985347" visual_id="12919"><math alttext="f(a_{n})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>?</p>
</div>
<hr/>
<div id="tags">
<span> real-analysis </span><span> functions </span><span> definition </span><span> recursion </span><span> peano-axioms </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="5588963"> `Why not just f()` Sequences can have repeated terms. Consider for example the sequence <span class="math-container" id="24985348" visual_id="7196304"><math alttext="1,2,1,3,1,4,1,5,\ldots" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>5</mn><mo>,</mo><mi mathvariant="normal">…</mi></mrow></semantics></math></span>. There is no <span class="math-container" id="24985349" visual_id="1"><math alttext="\,f\," class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mpadded lspace="1.7pt" width="+3.4pt"><mi>f</mi></mpadded></semantics></math></span> such that <span class="math-container" id="24985350" visual_id="9344059"><math alttext="\,a_{n+1}=f(a_{n})\," class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mpadded lspace="1.7pt" width="+1.7pt"><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mpadded></msub><mo>=</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo rspace="4.2pt" stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> for that sequence. </td></tr><tr><td comment_id="5588971"> Sometimes we might want to define a sequence <span class="math-container" id="24985351" visual_id="61613"><math alttext="(a_{0},a_{1},\ldots)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi mathvariant="normal">…</mi><mo stretchy="false">)</mo></mrow></semantics></math></span> by saying something like, let <span class="math-container" id="24985352" visual_id="22230"><math alttext="a_{0}=1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow></semantics></math></span> and let <span class="math-container" id="24985353" visual_id="3693910"><math alttext="a_{n}=n\cdot a_{n-1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mrow><mi>n</mi><mo>⋅</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></mrow></semantics></math></span> for all <span class="math-container" id="24985354" visual_id="967"><math alttext="n\geq 1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></semantics></math></span>. But, somebody else might object: does such a sequence really exist? And if there does exist a sequence satisfying these properties, is the sequence unique? (This objection would probably only come from someone who is trying to prove everything very carefully from the axioms.) </td></tr><tr><td comment_id="5588972"> @dxiv So we're just taking one input through a function, taking that output and putting it into some different function, taking that output and putting it into yet another function, etc? </td></tr><tr><td comment_id="5588974"> That's pretty much it. </td></tr><tr><td comment_id="5588975"> But still, why? What is this meant to accomplish or show? </td></tr><tr><td comment_id="5588976"> @user525966 Right, that's precisely what a recursive definition is. The rest is formalizing this intuition, and proving that `this procedure gives a single value to the sequence element a_n`. </td></tr><tr><td comment_id="5589018"> @dxiv So addition, if we let <span class="math-container" id="24985355" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> represent the successor function we have <span class="math-container" id="24985356" visual_id="488952"><math alttext="m+S(n)=S(m+n)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>m</mi><mo>+</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. If we think of <span class="math-container" id="24985381" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span> as a constant here where <span class="math-container" id="24985358" visual_id="7196305"><math alttext="a_{n}=m+n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub><mo>=</mo><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow></mrow></semantics></math></span>, then is it saying that <span class="math-container" id="24985359" visual_id="7196306"><math alttext="a_{S(n)}=f_{n}(a_{n})=S(a_{n})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></msub><mo>=</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>? Like pretend we're computing <span class="math-container" id="24985360" visual_id="54953"><math alttext="3+5" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>+</mo><mn>5</mn></mrow></semantics></math></span> where <span class="math-container" id="24985361" visual_id="38459"><math alttext="m=3" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>3</mn></mrow></semantics></math></span>. Then <span class="math-container" id="24985362" visual_id="7196307"><math alttext="3+5=a_{S(4)}=f_{4}(a_{4})=S(3+4)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mn>3</mn><mo>+</mo><mn>5</mn></mrow><mo>=</mo><msub><mi>a</mi><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow></mrow></msub><mo>=</mo><mrow><msub><mi>f</mi><mn>4</mn></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mn>3</mn><mo>+</mo><mn>4</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>? In the case of addition are all the <span class="math-container" id="24985363" visual_id="30908"><math alttext="f()" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>'s pretty much the same, just with different inputs? Because it looks like you could literally define <span class="math-container" id="24985364" visual_id="7196308"><math alttext="f_{n}(a_{n})=f(a_{n})=S(a_{n})=S(m+n)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>S</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> or something? </td></tr><tr><td comment_id="5589043"> @user525966 `f_n(a_n)=S(a_n)` Not sure I follow this right. If you want to add to the question, it would be better to edit the original post, rather than in comments. </td></tr><tr><td comment_id="5589046"> @dxiv added to the post </td></tr><tr><td comment_id="5589067"> `why not f(a_n)?` Because that doesn't work for recursive definitions *in general*, see my first comment. The top part you quoted was proving how recursive definitions work *in general*. You may not need to use the full generality of that definition in the second part (i.e. it may be enough to pick <span class="math-container" id="24985365" visual_id="8952625"><math alttext="\,f_{n}=f\," class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mpadded lspace="1.7pt" width="+1.7pt"><mi>f</mi><mi>n</mi></mpadded></msub><mo>=</mo><mpadded width="+1.7pt"><mi>f</mi></mpadded></mrow></semantics></math></span>), but I don't have that course handy, and there is not enough context to guess with complete confidence. </td></tr><tr><td comment_id="5589072"> I guess I can't think of a function definition that works that way, a different function for every value of <span class="math-container" id="24985393" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>? Is that unusual? </td></tr><tr><td comment_id="5589088"> In the example I mentioned above, we have <span class="math-container" id="24985367" visual_id="7196309"><math alttext="f_{n}(a_{n})=(n+1)a_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></mrow></semantics></math></span>. And that's a basic example, so this is not unusual at all. </td></tr><tr><td comment_id="5589106"> @littleO But then isn't this more a function of <span class="math-container" id="24985393" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> then? Since <span class="math-container" id="24985393" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> is the parameter for <span class="math-container" id="24985370" visual_id="3796"><math alttext="(n+1)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></semantics></math></span> as well as the index for <span class="math-container" id="24985371" visual_id="2733"><math alttext="a_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>n</mi></msub></semantics></math></span>? </td></tr><tr><td comment_id="5589115"> i.e. <span class="math-container" id="24985372" visual_id="7196310"><math alttext="f_{n\text{++}}=(n+1)f_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>n</mi><mo>⁢</mo><mtext>++</mtext></mrow></msub><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msub><mi>f</mi><mi>n</mi></msub></mrow></mrow></semantics></math></span> </td></tr><tr><td comment_id="5589306"> Well, in the example I gave, we have <span class="math-container" id="24985373" visual_id="7196311"><math alttext="a_{n+1}=f_{n}(a_{n})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, where <span class="math-container" id="24985374" visual_id="1755"><math alttext="f_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>n</mi></msub></semantics></math></span> is the function defined by <span class="math-container" id="24985375" visual_id="6552469"><math alttext="f_{n}(x)=(n+1)x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>x</mi></mrow></mrow></semantics></math></span>. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="2708450" id="answer">
<p>See <a href="https://books.google.it/books?id=ecTsDAAAQBAJ&amp;pg=PA23" rel="nofollow noreferrer"><em>footnote 3</em> (3rd ed., page 23)</a>: </p> <blockquote> <p>"<strong>Proposition 2.1.16</strong> (Recursive definitions) can be formalized more rigorously in the language of set theory." </p> </blockquote> <p>Thus, we have to use the <a href="https://en.wikipedia.org/wiki/Recursion#The_recursion_theorem" rel="nofollow noreferrer">Recursion Theorem</a>.</p> <p>Tao defines by recursion the function <span class="math-container" id="24985376" visual_id="40902"><math alttext="n+m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></semantics></math></span> (i.e. <span class="math-container" id="24985377" visual_id="2238962"><math alttext="+(n,m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>). It is a binary function, abd thus we can rewrite it as <span class="math-container" id="24985378" visual_id="7196312"><math alttext="F_{m}(n)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>m</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>. </p> <p>For <span class="math-container" id="24985379" visual_id="3350"><math alttext="n=0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow></semantics></math></span>, we have : <span class="math-container" id="24985380" visual_id="7196313"><math alttext="F_{m}(0)=0+m=m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi>F</mi><mi>m</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mn>0</mn><mo>+</mo><mi>m</mi></mrow><mo>=</mo><mi>m</mi></mrow></semantics></math></span> where <span class="math-container" id="24985381" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span> is used as the <span class="math-container" id="24985382" visual_id="159"><math alttext="a" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi></semantics></math></span> (or <span class="math-container" id="24985383" visual_id="146"><math alttext="c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi></semantics></math></span>) of the theorem.</p> <p>Then, assuming defined the case <span class="math-container" id="24985384" visual_id="40902"><math alttext="n+m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></semantics></math></span>, he uses it to define the next case: <span class="math-container" id="24985385" visual_id="7196314"><math alttext="F_{m}(s(n))=s(n)+m=s(n+m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi>F</mi><mi>m</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>s</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>s</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mi>m</mi></mrow><mo>=</mo><mrow><mi>s</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, where we use the previously defined <span class="math-container" id="24985386" visual_id="227854"><math alttext="(n+m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></semantics></math></span> and we use the <em>successor</em> function <span class="math-container" id="24985387" visual_id="11655"><math alttext="s(x)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> [denoted with <span class="math-container" id="24985388" visual_id="3760034"><math alttext="x++" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mo>+</mo></mrow></semantics></math></span> by Tao] as the function <span class="math-container" id="24985389" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> of the Recursion theorem.</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="2872344"> Understanding and proving prop 2.1.16 in Tao's Analysis I concerning recursive definitions </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
