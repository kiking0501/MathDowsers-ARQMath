<!DOCTYPE html>

<html>
<head>
<title>Calculating a random "blob" in a 10 x 10 grid</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Calculating a random "blob" in a 10 x 10 grid </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="2550621">
<p><strong>The problem:</strong></p> <ul> <li><p>You have a 10 x 10 grid where each cell can be either occupied (1) or unoccupied (0).</p></li> <li><p>All occupied cells in the grid are part of a single "blob": a single shape defined by a set of occupied coordinates for which each occupied coordinate has at least one occupied coordinate to either its top, left, bottom, and/or right.</p> <ul> <li>(From this definition it seems the blob must occupy at least two coordinates.)</li> </ul></li> <li><p>How can you quickly generate a blob that is chosen randomly from the set of all possible such blobs? If it's not possible to generate such a blob quickly, why is it not possible?</p></li> </ul> <p><strong>The (probably-wrong) method I'm using right now:</strong></p> <ol> <li>I choose a random cell from the 10 x 10 grid to be the first cell of the blob.</li> <li>I then choose randomly from the set of cells neighboring the first cell to create the second cell of the blob (to make sure every blob is valid).</li> <li>I then iterate through an updated-as-it's-added-to list of all of the current cells of the blob, considering each neighboring cell once (and only once).</li> <li>A certain percentage of the time, I add this neighboring candidate cell to the blob.  <ul> <li>Right now I'm using 50% as the percentage.</li> <li>If this method of generating the blob can work (i.e. it doesn't have any fundamental problems with it), I would need to know what this certain percentage should be.</li> </ul></li> </ol> <p><strong>My gut feelings of what the solution may look like:</strong></p> <ul> <li>It seems like the blob is generally going to occupy most of the 10 x 10 grid.</li> <li>It seems like it might be better to first choose the size of the blob, and only then choose which cells are occupied.</li> <li>I suspect that the ideal way of creating the blob <em>if I already know how big it should be</em> would be to choose a random cell and then to repeatedly choose a random neighbor to the existing blob and make it part of the blob.</li> <li>I suspect it may be helpful to first create an algorithm for a simpler one-dimensional grid before trying to create one for a two-dimensional grid.</li> </ul> <p><strong>Intermediate conclusions I'm coming to:</strong></p> <ul> <li>It looks like for the simpler case of a one-dimensional grid, the number of possible blobs is equal to the <span class="math-container" id="23583240" visual_id="170596"><math alttext="(n-1)th" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo mathvariant="normal" stretchy="false">(</mo><mrow><mi>n</mi><mo mathvariant="normal">-</mo><mn mathvariant="normal">1</mn></mrow><mo mathvariant="normal" stretchy="false">)</mo></mrow><mo mathvariant="italic">⁢</mo><mi>t</mi><mo mathvariant="italic">⁢</mo><mi>h</mi></mrow></semantics></math></span> <a href="https://math.stackexchange.com/a/60581/510058">triangular number</a>.  <ul> <li>See the pictures below that show a one-dimensional grid. The pattern of possible shapes as you move from <span class="math-container" id="23583241" visual_id="352"><math alttext="n=2" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow></semantics></math></span> to <span class="math-container" id="23583242" visual_id="350"><math alttext="n=3" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow></semantics></math></span> to <span class="math-container" id="23583243" visual_id="351"><math alttext="n=4" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn></mrow></semantics></math></span> is a triangular-number pattern.</li> </ul></li> </ul> <p><strong>Clarifications:</strong></p> <ul> <li>Two disconnected areas of occupied cells do not count as a single blob.</li> <li>Each possible blob needs to have an equal chance of being picked.</li> <li>Two blobs of the exact same size, shape, and orientation, but different location are considered different blobs.</li> <li>There are answers below which show how to generate a randomly-picked blob but where the randomly-selected blobs can't be generated quickly. I'm looking for a way to do it quickly or a proof that it's not possible to do it quickly.</li> </ul> <p><strong>Some pictures I drew to wrap my head around the issue:</strong></p> <p><a href="https://i.stack.imgur.com/fIH6X.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/fIH6X.png"/></a></p> <hr/> <p><a href="https://i.stack.imgur.com/W6ljr.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/W6ljr.png"/></a></p> <hr/> <p><a href="https://i.stack.imgur.com/yh8ol.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/yh8ol.png"/></a></p> <hr/> <p><a href="https://i.stack.imgur.com/cXb1B.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/cXb1B.png"/></a></p> <p><strong>Disclaimer:</strong></p> <ul> <li>I'm dealing with an interview question where I'm allowed to use third party help as long as I disclose it. The interview question isn't to generate the blob, but by being able to correctly generate a randomly-chosen blob I can test several different possible solutions to the interview question.</li> </ul> <hr/> <p><strong>Some clarifications of Misha's answer:</strong></p> <p>Q: Why do you say <em>"this method is definitely biased"</em>?</p> <p>A: Because we already know that the unbiased method works exactly the same way except you only accept the outcome of the random selection when the rules for a blob are applied "strictly" (i.e. you only have a blob when there's a single connected group of occupied spaces), and so if you instead just pick an occupied space and use its connected occupied spaces as the blob, you'll <em>at the very least</em> be biased towards smaller blobs.</p> <p>Q: What do the vertical bars represent?</p> <p>A: They represent size / cardinality. So <span class="math-container" id="23583244" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> is the blob itself, and <span class="math-container" id="23583245" visual_id="161257"><math alttext="|B|" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow></semantics></math></span> is how many cells it contains.</p> <p>Q: Why use the <span class="math-container" id="23583246" visual_id="187319"><math alttext="∂" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">∂</mi></semantics></math></span> character?</p> <p>A: In topology it refers to the boundary of a subset of a space.</p> <p>Q: How did you figure out the probability for the biased method?</p> <p>A: Well, <span class="math-container" id="23583247" visual_id="2528361"><math alttext="\frac{|B|}{100}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow><mn>100</mn></mfrac></semantics></math></span> is just the probability that you choose one of the cells of the blob, assuming it exists. So presumably the other part is the probability that it was created. To make it easier to understand, note that in the first formula you see that the odds of getting the strict blob you want (strict because you're not tolerating occupied cells not part of your blob) on any particular attempt is <span class="math-container" id="23583248" visual_id="257816"><math alttext="2^{-100}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mo>-</mo><mn>100</mn></mrow></msup></semantics></math></span>, because you need all 100 of those coin-flips to go exactly the way you want them. So in this less-strict situation, you need the coin-flips for your desired occupied spaces to go the way you want, and you also need the coin-flips for the unoccupied neighboring spaces to go the way you want, so that there's no chance you'll have a neighbor end up occupied and change the blob to a different one.</p> <p>Q: How did you figure out the lower bound?</p> <p>A: He just took some constraints he knew to be true and then used calculus(?) to combine those functions to determine what the lowest value could be. But to rationalize it: if you look at the formula for <span class="math-container" id="23583249" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> and say "I want to make <span class="math-container" id="23583250" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> as small as possible", you can see that you want to make the <span class="math-container" id="23583251" visual_id="2528362"><math alttext="(\frac{1}{2})^{|B|+|∂B|}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><mrow><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><mrow><mi mathvariant="normal">∂</mi><mo>⁢</mo><mi>B</mi></mrow><mo stretchy="false">|</mo></mrow></mrow></msup></semantics></math></span> term as small as possible, and the way to do that is to make <span class="math-container" id="23583252" visual_id="2528363"><math alttext="|B|+|∂B|" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><mrow><mi mathvariant="normal">∂</mi><mo>⁢</mo><mi>B</mi></mrow><mo stretchy="false">|</mo></mrow></mrow></semantics></math></span> as big as possible. And the biggest that sum can be is 100, where the blob and its neighboring cells take up the entire grid. Then you want to make the <span class="math-container" id="23583253" visual_id="2528361"><math alttext="\frac{|B|}{100}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow><mn>100</mn></mfrac></semantics></math></span> term as small as possible, and the way to do that is to figure out the smallest blob that where the blob and its neighbors fill the entire grid. But since he didn't try to find an actual blob, the number he ended up with (33) may not actually correspond to a real blob (I tried creating a blob of size 33 that occupied or bordered every cell and I couldn't do it). I think the effect of that is to make it take longer for the program to run than if the number were more accurate. If the number was perfectly accurate, then you'd have a 100% chance of accepting the rarest blobs, but with the number less accurate, you have less than a 100% chance of accepting the rarest blobs, but it should still be unbiased.</p> <p>Q: If the goal of multiplying by the acceptance probability is to get rid of the <span class="math-container" id="23583254" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> term, why use <span class="math-container" id="23583255" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span> in the numerator? Why not use "1"?</p> <p>A: Using a numerator greater than the probability of getting the rarest blobs (which is roughly <span class="math-container" id="23583256" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span>) will result in a non-uniform distribution, and using a numerator that's smaller will make the program take longer to run. The reason using a numerator greater than <span class="math-container" id="23583257" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span> will result in a non-uniform distribution is that it will lead us to accept some not-rarest blobs with the same probability as the rarest blobs. If we have the numerator as <span class="math-container" id="23583258" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span>, then when we actually come across one of those rarest blobs, the <span class="math-container" id="23583259" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> will <em>equal</em> <span class="math-container" id="23583260" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span>, and so the acceptance probability will be "1" (we'll always accept that blob). But if the numerator is larger, not only will we always accept the rarest blobs, but we will also always accept the less-rare blobs whose <span class="math-container" id="23583261" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> is such that dividing the larger numerator by <span class="math-container" id="23583262" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> will result in an acceptance probability of at least 1.</p>
</div>
<hr/>
<div id="tags">
<span> probability </span><span> combinatorics </span><span> algorithms </span><span> computational-mathematics </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="5265969"> This OEIS-sequence: http://oeis.org/A134262 is related to the question but it's not the number of blobs, since, as I understood, a blob should also be connected (for example <span class="math-container" id="23583263" visual_id="2528364"><math alttext="[1,1,0,1,1]" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></semantics></math></span> isn't a blob (but two blobs)?). And, the more trivial point, the empty grid isn't a blob(?) </td></tr><tr><td comment_id="5266082"> @ploosu2 Yes, both those statements match my understanding of the question. The blob refers to the set of occupied spaces. </td></tr><tr><td comment_id="5266104"> When you say that you need to randomly chose a blob from all possible blobs, does that mean that each blob needs to have an equal chance of being picked? If so, then your method will most likely not work, since (depending on the percentage that you set), most likely it will bias picking certain sizes of blobs over others. Indeed, if so, I'd agree with your intuition that it might be a good idea to first pick the size of the blob, with a chance proportional to how many possible blobs there are of that size. But likewise you'd need to see how you can avoid any biases in shape. </td></tr><tr><td comment_id="5266123"> @Bram28 The answer to your question is "Yes". And yes, I have seen exactly the issues you point out when I run my code that generates the blobs this way: it seems to bias towards small blobs, and the blob shapes seem biased towards being round-ish instead of branched with lots of holes inside. </td></tr><tr><td comment_id="5266145"> @NathanWailes Yeah, I figured.  Of course you can get greater blobs by just increasing that percentage, but then it will be biased for those larger sizes!  And the shape seems to be greatly biased by your method as well. Hmmm, I'll have to think about this.  One more clarification question though: are two  blobs of the exact same size, shape, and orientation, but different location considered the same or different? </td></tr><tr><td comment_id="5266147"> @Bram28 They'd be considered different. </td></tr><tr><td comment_id="5266148"> @NathanWailes OK, I *think* that's good news for a possible algorithm .. though I don't see one yet... </td></tr><tr><td comment_id="5266267"> One way could be to choose a random cell as a starting point then assign a random nibble where each bit corresponds to NSEW. In the cells that are on (1) [new branch], place a corresponding nibble that indicates which cell turned it on. Once all new cells in the current branch generate no new cells, the process stops. Since each cell is just being assigned a 0-15 number, it should maintain an even distribution for the probability of a blob. It also shouldn't have bias for blob shape. </td></tr><tr><td comment_id="5266275"> It seems 2 disconnected blob is a blob </td></tr><tr><td comment_id="5266292"> A naive but correct way to do this, is to randomly populate the whole grid, determine if the result is a blob or not, if it is, then stop, otherwise generate again. </td></tr><tr><td comment_id="5266309"> @kmeis I don't understand what you mean by "nibble", "bit", "(1)[new branch]", and "a 0-15 number". </td></tr><tr><td comment_id="5266319"> @lion I updated the description to specify that two disconnected shapes would not count as a blob. I also had thought of the naive approach but I wasn't sure if it was correct, and I also thought the odds of finding a blob were too low, but I'm going to give it a go now and see if it finds something. </td></tr><tr><td comment_id="5266324"> @NathanWailes I mean a number from 0-15, binary it is represented by 0000-1111. Since there are four cells in a neighborhood of a blob, you can represent a cell shaded by some binary number (IE 1011 could mean shade North, east, and west). I believe since you are simply just generating a random number between 0-15, then no blob size or shape should be "favored" unequally. That is, smaller blobs will be more likely, but there are more possibilities for them. They should represented evenly in their space. </td></tr><tr><td comment_id="5266338"> The naive way is by definition correct (regardless of the definition of the blob), but I agree with you it may not be the most efficient. </td></tr><tr><td comment_id="5266341"> @kmeis That would seem to favor small blob sizes. For example, 1/16th of the time I'd end up with a 1-cell occupied area. </td></tr><tr><td comment_id="5266357"> @Nathan Wailes: I am a bit confused then. Smaller blobs should be favored, since 2-celled blobs have much more possibilities. I mean, a 100 celled blob only can happen one way, it should not be represented as much as a 2 celled blob if it is evenly distributed (chosen from the space of all possible blobs).  Since a blob is by definition 2-celled, you could just randomize from 1-15 for the first assignment, then 0-16 after. </td></tr><tr><td comment_id="5266387"> @kmeis There are almost certainly exponentially many 50-celled blobs, though: far more than there are 2-celled blobs. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="2550968" id="answer">
<p>A definitely correct but inefficient method is to</p> <ol> <li>Randomly choose which of the <span class="math-container" id="23583264" visual_id="7905"><math alttext="100" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>100</mn></semantics></math></span> cells are occupied, independently with a probability of <span class="math-container" id="23583265" visual_id="363"><math alttext="\frac{1}{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac></semantics></math></span> for each cell.</li> <li>Check if there is a single blob. If not, start over. If so, output this blob.</li> </ol> <p>Step 1 is equally likely to generate each blob (as well as all the non-blobs), so the result (once a blob finally is generated) is equally likely to be any blob. More precisely, let <span class="math-container" id="23583266" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> be the probability that we get something that <em>isn't</em> a blob. Then the probability of generating your favorite blob <span class="math-container" id="23583267" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> on the <span class="math-container" id="23583268" visual_id="29978"><math alttext="k^{\text{th}}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>k</mi><mtext>th</mtext></msup></semantics></math></span> trial is <span class="math-container" id="23583269" visual_id="2528365"><math alttext="f^{k-1}\cdot\frac{1}{2^{100}}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mfrac><mn>1</mn><msup><mn>2</mn><mn>100</mn></msup></mfrac></mrow></semantics></math></span>: we failed to get a blob <span class="math-container" id="23583270" visual_id="11609"><math alttext="k-1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></semantics></math></span> times, and then finally got all the cells in <span class="math-container" id="23583271" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> and no others. So the overall probability of getting blob <span class="math-container" id="23583272" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> with this method is <span class="math-container" id="23583273" visual_id="2528366"><math alttext="\frac{2^{-100}}{1-f}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msup><mn>2</mn><mrow><mo>-</mo><mn>100</mn></mrow></msup><mrow><mn>1</mn><mo>-</mo><mi>f</mi></mrow></mfrac></semantics></math></span>, which doesn't depend on <span class="math-container" id="23583274" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span>, and therefore all blobs are equally likely.</p> <p>We choose a probability of <span class="math-container" id="23583275" visual_id="363"><math alttext="\frac{1}{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac></semantics></math></span> so that on each trial, any blob <span class="math-container" id="23583276" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> has the same probability of <span class="math-container" id="23583277" visual_id="257816"><math alttext="2^{-100}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mrow><mo>-</mo><mn>100</mn></mrow></msup></semantics></math></span> of being generated. If the probability were <span class="math-container" id="23583278" visual_id="286414"><math alttext="p\neq\frac{1}{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≠</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></semantics></math></span>, then the probability of generating a <span class="math-container" id="23583279" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span>-celled blob would be <span class="math-container" id="23583280" visual_id="2528367"><math alttext="p^{k}(1-p)^{100-k}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mi>k</mi></msup><mo>⁢</mo><msup><mrow><mo stretchy="false">(</mo><mrow><mn>1</mn><mo>-</mo><mi>p</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mn>100</mn><mo>-</mo><mi>k</mi></mrow></msup></mrow></semantics></math></span>, which is not uniform.</p> <p>Unfortunately, it will probably take a very long time to generate a blob with this method, since a random subset of the cells usually doesn't form a connected blob.</p> <hr/> <p>Next, here is an actually feasible method.</p> <p>First, consider the following sampling method, which is <em>not</em> uniform:</p> <ol> <li>Randomly choose which of the <span class="math-container" id="23583281" visual_id="7905"><math alttext="100" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>100</mn></semantics></math></span> cells are occupied, independently with a probability of <span class="math-container" id="23583282" visual_id="363"><math alttext="\frac{1}{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac></semantics></math></span> for each cell.</li> <li>Choose a cell uniformly at random. If it is not occupied (or if it has no occupied neighbors, so it doesn't count as a blob), start over. Otherwise, let <span class="math-container" id="23583283" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> be the connected component containing the chosen cell.</li> </ol> <p>Even though this method is definitely biased, it has the nice feature that we know exactly the probability with which a blob <span class="math-container" id="23583284" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> is returned in a single trial. That probability is <span class="math-container" id="23583285" visual_id="2528368"><math alttext="p(B)=\frac{|B|}{100}\left(\frac{1}{2}\right)^{|B|+|\partial B|}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mfrac><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow><mn>100</mn></mfrac><mo>⁢</mo><msup><mrow><mo>(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>)</mo></mrow><mrow><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow><mo>+</mo><mrow><mo stretchy="false">|</mo><mrow><mo>∂</mo><mo>⁡</mo><mi>B</mi></mrow><mo stretchy="false">|</mo></mrow></mrow></msup></mrow></mrow></semantics></math></span> where <span class="math-container" id="23583286" visual_id="161257"><math alttext="|B|" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow></semantics></math></span> is the number of occupied cells in <span class="math-container" id="23583287" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> and <span class="math-container" id="23583288" visual_id="2528369"><math alttext="|\partial B|" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">|</mo><mrow><mo>∂</mo><mo>⁡</mo><mi>B</mi></mrow><mo stretchy="false">|</mo></mrow></semantics></math></span> is the number of unoccupied cells bordering <span class="math-container" id="23583289" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span>. Moreover, we can put a lower bound on <span class="math-container" id="23583290" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> for any <span class="math-container" id="23583291" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span>: it is <span class="math-container" id="23583292" visual_id="2528370"><math alttext="p^{*}=\frac{33}{100}(\frac{1}{2})^{100}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo>*</mo></msup><mo>=</mo><mrow><mfrac><mn>33</mn><mn>100</mn></mfrac><mo>⁢</mo><msup><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><mn>100</mn></msup></mrow></mrow></semantics></math></span>. (This is the minimum of <span class="math-container" id="23583293" visual_id="2528371"><math alttext="\frac{x}{100}(\frac{1}{2})^{x+y}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>x</mi><mn>100</mn></mfrac><mo>⁢</mo><msup><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow></msup></mrow></semantics></math></span> over all <span class="math-container" id="23583294" visual_id="921"><math alttext="x,y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow></semantics></math></span> with <span class="math-container" id="23583295" visual_id="15134"><math alttext="x\geq 2" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≥</mo><mn>2</mn></mrow></semantics></math></span>, <span class="math-container" id="23583296" visual_id="8813"><math alttext="y\geq 0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>≥</mo><mn>0</mn></mrow></semantics></math></span>, <span class="math-container" id="23583297" visual_id="2528372"><math alttext="x+y\leq 100" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo>≤</mo><mn>100</mn></mrow></semantics></math></span>, and <span class="math-container" id="23583298" visual_id="2528373"><math alttext="y\leq 2x+2" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>≤</mo><mrow><mrow><mn>2</mn><mo>⁢</mo><mi>x</mi></mrow><mo>+</mo><mn>2</mn></mrow></mrow></semantics></math></span>: the constraints on <span class="math-container" id="23583299" visual_id="161257"><math alttext="|B|" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow></semantics></math></span> and <span class="math-container" id="23583300" visual_id="2528369"><math alttext="|\partial B|" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">|</mo><mrow><mo>∂</mo><mo>⁡</mo><mi>B</mi></mrow><mo stretchy="false">|</mo></mrow></semantics></math></span>.)</p> <p>Now modify the method above to make the following method:</p> <ol> <li>Randomly choose which of the <span class="math-container" id="23583301" visual_id="7905"><math alttext="100" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>100</mn></semantics></math></span> cells are occupied, independently with a probability of <span class="math-container" id="23583302" visual_id="363"><math alttext="\frac{1}{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>2</mn></mfrac></semantics></math></span> for each cell.</li> <li>Choose a cell uniformly at random. If it is not occupied (or if it has no occupied neighbors, so it doesn't count as a blob), start over. Otherwise, let <span class="math-container" id="23583303" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> be the connected component containing the chosen cell.</li> <li>With probability <span class="math-container" id="23583304" visual_id="2528374"><math alttext="p^{*}/p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>p</mi><mo>*</mo></msup><mo>/</mo><mi>p</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, return <span class="math-container" id="23583305" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span>. Otherwise, start over.</li> </ol> <p>Now, on any given trial, the probability that <span class="math-container" id="23583306" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> is the blob we get after step 2 is is <span class="math-container" id="23583307" visual_id="291765"><math alttext="p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>. But the probability that we actually return <span class="math-container" id="23583308" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> is that probability times the acceptance probability: <span class="math-container" id="23583309" visual_id="2528375"><math alttext="p(B)\cdot p^{*}/p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow><mo>⋅</mo><msup><mi>p</mi><mo>*</mo></msup></mrow><mo>/</mo><mi>p</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, or <span class="math-container" id="23583310" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span>. So on any given trial, every blob has the same chance <span class="math-container" id="23583311" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span> of being produced.</p> <p>Experimentally, the average value of <span class="math-container" id="23583312" visual_id="2528376"><math alttext="\frac{p^{*}}{p(B)}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msup><mi>p</mi><mo>*</mo></msup><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></mfrac></semantics></math></span> seems to be between <span class="math-container" id="23583313" visual_id="22655"><math alttext="0.001" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.001</mn></semantics></math></span> and <span class="math-container" id="23583314" visual_id="443665"><math alttext="0.0001" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.0001</mn></semantics></math></span>, which means the average number of times steps 1-2 are repeated is not <span class="math-container" id="23583315" visual_id="106401"><math alttext="2^{100}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>100</mn></msup></semantics></math></span> (as with the first method) but fewer than <span class="math-container" id="23583316" visual_id="31040"><math alttext="10000" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>10000</mn></semantics></math></span>. This means we can actually run this algorithm in a few seconds as opposed to the lifetime of the universe.</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="5266397"> @Bram28 I've proved that it's not biased between blobs. It's not the *size* of the blob you want to be uniform, it's the blob itself. There are way more size-50 blobs than there are size-2 or size-100. Each individual blob of size 50 is just as likely as each individual blob of size 2 or 100. </td></tr><tr><td comment_id="5266425"> Ah, yes, I see it now. By setting the percentage to <span class="math-container" id="23583328" visual_id="10141"><math alttext="50" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>50</mn></semantics></math></span>%, each specific blob is equally likely the outcome. Nice! </td></tr><tr><td comment_id="5266460"> @MishaLavrov I just had to spend some time thinking about your answer. Thanks a lot, it makes a lot of sense. I'll just add two clarifications for future readers, feel free to add them to the answer for future readers (or not): 1) I'd been wondering why the probability was 1/2, and it's a result of the phrase "equally likely". That "equally likely" phrase is what makes the 50% necessary. Look at the N=2 picture and see how each of the final four states are "equally likely", and it's because each cell has a 50% chance of being filled (each branch has a 50% chance of going either way). </td></tr><tr><td comment_id="5266462"> 2) I would change the phrase "The overall probability of getting blob B" above to "the probability of getting blob B *when choosing uniformly from the set of all possible blobs*". </td></tr><tr><td comment_id="5266473"> Also I'm going to leave the question open because I'm hoping to get an algorithm that can be used to generate a randomly-picked blob quickly, or a proof that it's not possible. I'll update the question to specify this. </td></tr><tr><td comment_id="5266589"> The OP suggests that there should be only one single cell blob in the set of all possible blobs, but this algorithm would have 100 of them. Similarly for two-cell blobs (where it is explicitly stated that there is just one). The question should make it clear if blobs are differentiated on the basis of their location and orientation. </td></tr><tr><td comment_id="5266782"> @Dean In the "Clarifications" section of the question, I specify that the same shape in different locations should be considered two different blobs. I'll move that section up above the pictures. </td></tr><tr><td comment_id="5268037"> @NathanWailes I now have a method that works in a few seconds on my laptop (on average). </td></tr><tr><td comment_id="5273312"> @MishaLavrov Thank you! I had to take some time to think about what you wrote and implement the algorithm, and it seems to be working! I added some comments to the bottom of my question to clarify some things I was confused about in your update to your answer, I'd be interested in knowing if anything I concluded was not accurate. </td></tr><tr><td comment_id="5273860"> @NathanWailes You're basically right about everything. The way I got the parameters in <span class="math-container" id="23583318" visual_id="183933"><math alttext="p^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>*</mo></msup></semantics></math></span> was by having my laptop try all possibilities for <span class="math-container" id="23583319" visual_id="66"><math alttext="(x,y)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></semantics></math></span>, and you're probably right that a <span class="math-container" id="23583320" visual_id="2528377"><math alttext="(33,67)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>33</mn><mo>,</mo><mn>67</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> split isn't actually possible. (But I found a <span class="math-container" id="23583321" visual_id="2528378"><math alttext="(42,58)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>42</mn><mo>,</mo><mn>58</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> blob, so it's pretty close.) And I want to emphasize that the reason we accept with probability <span class="math-container" id="23583322" visual_id="2528374"><math alttext="p^{*}/p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>p</mi><mo>*</mo></msup><mo>/</mo><mi>p</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> rather than <span class="math-container" id="23583323" visual_id="2528379"><math alttext="C/p(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>C</mi><mo>/</mo><mi>p</mi></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> for any other constant <span class="math-container" id="23583324" visual_id="505"><math alttext="C" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi></semantics></math></span> is to make sure that the probability of accepting is always at most <span class="math-container" id="23583325" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span>: if it's not, that step just doesn't make sense. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="60578"> What is the term for a factorial type operation, but with summation instead of products? </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
