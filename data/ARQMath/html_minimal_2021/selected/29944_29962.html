<!DOCTYPE html>

<html>
<head>
<title>Difference between linear map and homomorphism</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Difference between linear map and homomorphism </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="29944">
<p>I came across the following definition:</p> <p>Given a ring <span class="math-container" id="308744" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>, with a unit <span class="math-container" id="308745" visual_id="14290"><math alttext="1\in A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∈</mo><mi>A</mi></mrow></semantics></math></span>, and <span class="math-container" id="308746" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>-modules <span class="math-container" id="308747" visual_id="4"><math alttext="M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi></semantics></math></span> and <span class="math-container" id="308748" visual_id="320"><math alttext="N" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi></semantics></math></span>, we denote by <span class="math-container" id="308749" visual_id="284277"><math alttext="Hom(M,N)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> or <span class="math-container" id="308750" visual_id="1084868"><math alttext="Hom_{A}(M,N)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><msub><mi>m</mi><mi>A</mi></msub><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> the space of <span class="math-container" id="308751" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>-linear maps from <span class="math-container" id="308752" visual_id="4"><math alttext="M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi></semantics></math></span> to <span class="math-container" id="308753" visual_id="320"><math alttext="N" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi></semantics></math></span>.</p> <p>My question is: what exactly is the difference between homomorphism and a linear map? I can see that linearity is defined in terms of a vector space or module and homomorphism in terms of groups.</p> <p>But every linear map is a homomorphism and when treating a group as a one dimensional vector space over itself, every homo. is also a linear map. This makes me think they are kind of the same.</p> <p>Is it ok to think of it that way? Or am I confused? Because I feel confused. Thanks once again for your help!</p>
</div>
<hr/>
<div id="tags">
<span> abstract-algebra </span><span> terminology </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="64061"> Vector spaces are defined over fields, not groups, so you cannot in general consider a group to be a one-dimensional vector space over itself. Of course abelian groups can be regarded as modules over the integers. And some types of groups can be considered as vector spaces. For example, elementary abelian <span class="math-container" id="308755" visual_id="74"><math alttext="p" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi></semantics></math></span>-groups can be considered as vector spaces over the field of order <span class="math-container" id="308755" visual_id="74"><math alttext="p" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi></semantics></math></span>, and homomorphisms between two such groups are the same as linear maps between the corresponding vector spaces, </td></tr><tr><td comment_id="64099"> @Derek: yes, you're right! Thanks for pointing out that I cannot treat an arbitrary group as a one dimensional vector space. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="29962" id="answer">
<p>"Homomorphism" comes from the greek <em>homo</em> (same) and <em>morphus</em> (form or shape).</p> <p>So a "homomorphism" is a map that "preserves the shape" or "preserves the structure."</p> <ul> <li><p>If you are working with groups, you want <span class="math-container" id="308756" visual_id="4512"><math alttext="f\colon G\to H" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>G</mi><mo>→</mo><mi>H</mi></mrow></mrow></semantics></math></span> to preserve the group structure: identity, inverses, and products. So a homomorphism is a map <span class="math-container" id="308757" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> such that <span class="math-container" id="308758" visual_id="2611"><math alttext="f(1)=1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow></semantics></math></span>, <span class="math-container" id="308759" visual_id="1729895"><math alttext="f(a^{-1})=(f(a))^{-1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msup><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></semantics></math></span>, and <span class="math-container" id="308760" visual_id="554357"><math alttext="f(ab)=f(a)f(b)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>⁢</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> (though it turns out that the latter is enough to guarantee all of them, so we only check the latter). </p></li> <li><p>If you are working with rings, you want <span class="math-container" id="308761" visual_id="31500"><math alttext="f\colon R\to S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>R</mi><mo>→</mo><mi>S</mi></mrow></mrow></semantics></math></span> to preserve the ring structure (addition and multiplication; if the rings have unity, then you want it to preserve unity). So you want <span class="math-container" id="308762" visual_id="779010"><math alttext="f(a+b)=f(a)+f(b)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></semantics></math></span>, <span class="math-container" id="308763" visual_id="554357"><math alttext="f(ab)=f(a)f(b)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>⁢</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> (and if both rings have unity, you often want <span class="math-container" id="308764" visual_id="296777"><math alttext="f(1_{R})=1_{S}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mn>1</mn><mi>R</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mn>1</mn><mi>S</mi></msub></mrow></semantics></math></span>).</p></li> <li><p>If you are working with partially ordered sets, you want <span class="math-container" id="308765" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> to preserve the order structure. So you want that if <span class="math-container" id="308766" visual_id="13221"><math alttext="a\leq b" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow></semantics></math></span>, then <span class="math-container" id="308767" visual_id="126038"><math alttext="f(a)\leq f(b)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≤</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>.</p></li> <li><p>If you are working with graphs, you want the homomorphisms to preserve the graph structure, which is adjacency: if <span class="math-container" id="308768" visual_id="1546"><math alttext="v" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi></semantics></math></span> is adjacent to <span class="math-container" id="308769" visual_id="60"><math alttext="w" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi></semantics></math></span>, you want <span class="math-container" id="308770" visual_id="5280"><math alttext="f(v)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> to be adjacent to <span class="math-container" id="308771" visual_id="65662"><math alttext="f(w)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>.</p></li> <li><p>If you are working with topological spaces, you want homomorphisms to preserve the topological space structure; it turns out that the way to do this is to ask that the inverse image of an open set be open.</p></li> <li><p>If you are working with "pointed sets" (sets with a distinguished object), then you want a homomorphism <span class="math-container" id="308772" visual_id="67906"><math alttext="f\colon S\to T" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>S</mi><mo>→</mo><mi>T</mi></mrow></mrow></semantics></math></span> to "preserve the structure", so you require it to map the distinguished object of <span class="math-container" id="308773" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> to the distinguished object of <span class="math-container" id="308774" visual_id="319"><math alttext="T" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi></semantics></math></span>.</p></li> <li><p>And if you are working with vector spaces over a field <span class="math-container" id="308775" visual_id="75"><math alttext="F" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi></semantics></math></span>, you want a homomorphism <span class="math-container" id="308776" visual_id="51044"><math alttext="f\colon V\to W" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>V</mi><mo>→</mo><mi>W</mi></mrow></mrow></semantics></math></span> to "preserve the vector space structure"; so you want it to preserve the additive structure, <span class="math-container" id="308777" visual_id="10751"><math alttext="f(x+y)=f(x)+f(y)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></semantics></math></span>; and the scalar multiplication structure, <span class="math-container" id="308778" visual_id="1607283"><math alttext="f(av)=af(v)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>⁢</mo><mi>v</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>a</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. </p></li> <li><p>Similarly, if you are working with <span class="math-container" id="308779" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>-modules, a homomorphism will be a map <span class="math-container" id="308780" visual_id="43309"><math alttext="f\colon M\to N" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>M</mi><mo>→</mo><mi>N</mi></mrow></mrow></semantics></math></span> that preserves "the <span class="math-container" id="308781" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>-module structure", <span class="math-container" id="308782" visual_id="1729896"><math alttext="f(m+m^{\prime})=f(m)+f(m^{\prime})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><mo>+</mo><msup><mi>m</mi><mo>′</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo>+</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>m</mi><mo>′</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></semantics></math></span> and <span class="math-container" id="308783" visual_id="1729897"><math alttext="f(rm)=rf(m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>r</mi><mo>⁢</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>r</mi><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>.</p></li> </ul> <p>So the meaning of "homomorphism" will depend on the context. It is often clear. If I say "Let <span class="math-container" id="308784" visual_id="673"><math alttext="G" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi></semantics></math></span> and <span class="math-container" id="308785" visual_id="1116"><math alttext="H" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi></semantics></math></span> be groups, and let <span class="math-container" id="308786" visual_id="4512"><math alttext="f\colon G\to H" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>G</mi><mo>→</mo><mi>H</mi></mrow></mrow></semantics></math></span> be a homomorphism", then it's pretty clear I'm talking about a group homomorphism. </p> <p>But sometimes it isn't clear. What if I say "Let <span class="math-container" id="308787" visual_id="187613"><math alttext="f\colon\mathbb{Z}\to\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>ℤ</mi><mo>→</mo><mi>ℝ</mi></mrow></mrow></semantics></math></span> be a homomorphism"? Am I talking about a homomorphism of additive groups, or a homomorphism of rings? How about "<span class="math-container" id="308788" visual_id="161014"><math alttext="f\colon\mathbb{R}\to\mathbb{C}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>ℝ</mi><mo>→</mo><mi>ℂ</mi></mrow></mrow></semantics></math></span>"? Am I talking about additive groups, rings, topological spaces,  <span class="math-container" id="308789" visual_id="448"><math alttext="\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℝ</mi></semantics></math></span>-vector spaces, <span class="math-container" id="308790" visual_id="856"><math alttext="\mathbb{Q}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℚ</mi></semantics></math></span>-vector spaces, inner product spaces? Which?</p> <p>So we often specify what <em>kind</em> of homomorphism we mean. This is especially important when a particular set has many different structures (such as <span class="math-container" id="308791" visual_id="448"><math alttext="\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℝ</mi></semantics></math></span>, which is an additive group, a field, a vector space over <span class="math-container" id="308792" visual_id="856"><math alttext="\mathbb{Q}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℚ</mi></semantics></math></span>, a vector space over <span class="math-container" id="308793" visual_id="448"><math alttext="\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℝ</mi></semantics></math></span>, etc). So we will say things like "let <span class="math-container" id="308794" visual_id="43309"><math alttext="f\colon M\to N" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>M</mi><mo>→</mo><mi>N</mi></mrow></mrow></semantics></math></span> be an <span class="math-container" id="308795" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>-module homomorphism", or "let <span class="math-container" id="308796" visual_id="161014"><math alttext="f\colon\mathbb{R}\to\mathbb{C}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>ℝ</mi><mo>→</mo><mi>ℂ</mi></mrow></mrow></semantics></math></span> be an additive homomorphism" to specify which kind we are thinking about.</p> <p>And, historically, some terminology precedes the generic "homomorphism." Homomorphisms of vector spaces have long been called "linear transformations", so we often call them that instead of "vector space homomorphism". When a vector space has several structures as a vector space (e.g., <span class="math-container" id="308797" visual_id="3686"><math alttext="\mathbb{C}^{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℂ</mi><mn>2</mn></msup></semantics></math></span> can be thought of as a complex vector space or as a real vector space), we often specify the field, so we may say things like "let <span class="math-container" id="308798" visual_id="621266"><math alttext="f\colon\mathbb{C}^{2}\to\mathbb{C}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><msup><mi>ℂ</mi><mn>2</mn></msup><mo>→</mo><mi>ℂ</mi></mrow></mrow></semantics></math></span> be an <span class="math-container" id="308799" visual_id="448"><math alttext="\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℝ</mi></semantics></math></span>-linear transformation" or just "<span class="math-container" id="308800" visual_id="448"><math alttext="\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℝ</mi></semantics></math></span>-linear", to specify we are looking at the structure as a real vector space.</p> <p>Because modules are a direct generalization of vector spaces, we often say "<span class="math-container" id="308801" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>-linear function" or "<span class="math-container" id="308802" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>-linear" to refer to homomorphisms of <span class="math-container" id="308803" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>-modules, by analogy to <span class="math-container" id="308804" visual_id="448"><math alttext="\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℝ</mi></semantics></math></span>-linear or <span class="math-container" id="308805" visual_id="1492"><math alttext="\mathbb{C}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℂ</mi></semantics></math></span>-linear for homomorphisms of real or complex vector spaces. Note that a module over a field is the same thing as a vector space. </p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="64180"> thank you so much! Now I even learnt more than I asked for, e.g. I didn't know there was such a thing as a homomorphism between topological spaces. In fact, I tried to look it up on Wikipedia after reading your answer but it's not mentioned there. So a continuous function between top. spaces can also be called homomorphism! </td></tr><tr><td comment_id="64187"> @Matt: Well, it's a "homomorphism of topological spaces", or "a homomorphism in the category of topological spaces", but almost nobody calls them that. (-: </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
