<!DOCTYPE html>

<html>
<head>
<title>First order logic "abbreviation"</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> First order logic "abbreviation" </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="2599194">
<p>I am curious what justifies the use of shorthands or abbreviations for certain formulas in first order logic. In particular, I'm interested in building up some basic mathematical principles from the zfc axioms and there's many times when a new symbol is introduced which expresses some logical statement more succinctly. My question is how this is logically or syntactically justified. For example, in the Wikipedia article for <a href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory#1._Axiom_of_extensionality" rel="nofollow noreferrer">Zermelo Fraenkel set theory</a> under the Axiom of Extensionality it is stated that <span class="math-container" id="24036033" visual_id="3940"><math alttext="x=y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></semantics></math></span> can be taken to be shorthand for</p> <p><span class="math-container" id="24036034" visual_id="3740702"><math alttext="\forall z[z\in x\Leftrightarrow z\in y]\land\forall w[x\in w\Leftrightarrow y% \in w]\hskip 1.0ptin(1)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>z</mi><mrow><mo stretchy="false">[</mo><mi>z</mi><mo>∈</mo><mi>x</mi><mo>⇔</mo><mi>z</mi><mo>∈</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><mo>∧</mo><mo>∀</mo><mi>w</mi><mrow><mo stretchy="false">[</mo><mi>x</mi><mo>∈</mo><mi>w</mi><mo>⇔</mo><mi>y</mi><mo>∈</mo><mi>w</mi><mo rspace="3.5pt" stretchy="false">]</mo></mrow><mi>i</mi><mi>n</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span></p> <p>The way I interpret that is anywhere we see the above expression we can delete it and "plug in" <span class="math-container" id="24036035" visual_id="3940"><math alttext="x=y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></semantics></math></span>.</p> <p>My questions are as follows.</p> <p>First, is there a way to notationally indicate that the expression <span class="math-container" id="24036036" visual_id="3940"><math alttext="x=y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></semantics></math></span> and the expression in <span class="math-container" id="24036037" visual_id="749"><math alttext="(1)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> are related in such a way (logically equivalent?) that one can (without any intervening steps?) simply replace one by the other in any expression?</p> <p>Second, which rules of logic allows us to create definitions like <span class="math-container" id="24036038" visual_id="3940"><math alttext="x=y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></semantics></math></span> and which rules allow us to make the replacements indicated above?</p> <p>As a slightly simpler example or a hint at what I feel might be the answer, suppose we have the two axioms</p> <p><span class="math-container" id="24036039" visual_id="297373"><math alttext="B\Leftrightarrow C" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⇔</mo><mi>C</mi></mrow></semantics></math></span> <span class="math-container" id="24036040" visual_id="10132"><math alttext="A\land B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow></semantics></math></span></p> <p>Now in a few lines we could derive <span class="math-container" id="24036041" visual_id="1151507"><math alttext="A\land C" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>C</mi></mrow></semantics></math></span>. However, it seems to me that if we have ANY formula involving <span class="math-container" id="24036042" visual_id="505"><math alttext="C" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi></semantics></math></span> we could in some number of lines derive the same expression but with <span class="math-container" id="24036043" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> replaced by <span class="math-container" id="24036044" visual_id="505"><math alttext="C" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi></semantics></math></span>. This would especially be useful in very complicated expressions where <span class="math-container" id="24036045" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> might be embedded pretty deeply in the expression and it would be hard to get at <span class="math-container" id="24036046" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> to replace it with <span class="math-container" id="24036047" visual_id="505"><math alttext="C" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi></semantics></math></span> using the usual rules of deduction. Is there something that allows us to replace all instances of <span class="math-container" id="24036048" visual_id="599"><math alttext="B" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi></semantics></math></span> with <span class="math-container" id="24036049" visual_id="505"><math alttext="C" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi></semantics></math></span> if we have an expression like <span class="math-container" id="24036050" visual_id="1142225"><math alttext="Cov(X^{2},Y)=\sum\sum_{(x,y)\in S}(x^{2}-\mu_{x}^{2})(y-\mu_{y})f(x,y)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>C</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>v</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>X</mi><mn>2</mn></msup><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo largeop="true" symmetric="true">∑</mo><mrow><msub><mo largeop="true" symmetric="true">∑</mo><mrow><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo>∈</mo><mi>S</mi></mrow></msub><mrow><mrow><mo stretchy="false">(</mo><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>-</mo><msubsup><mi>μ</mi><mi>x</mi><mn>2</mn></msubsup></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>y</mi><mo>-</mo><msub><mi>μ</mi><mi>y</mi></msub></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></semantics></math></span>.</p> <p>I would appreciate someone pointing me towards the correct concepts I should be looking up and some proper notation for the concepts I am trying to express!</p> <p>Also note: I don't really know the meaning of things like <span class="math-container" id="24036051" visual_id="49997"><math alttext="\vdash" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊢</mo></semantics></math></span>, <span class="math-container" id="24036052" visual_id="1014"><math alttext="\vDash" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><merror class="ltx_ERROR undefined undefined"><mtext>\vDash</mtext></merror></semantics></math></span>, or the difference between <span class="math-container" id="24036053" visual_id="63823"><math alttext="\leftrightarrow" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>↔</mo></semantics></math></span>, <span class="math-container" id="24036054" visual_id="1183"><math alttext="\Leftrightarrow" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⇔</mo></semantics></math></span>, <span class="math-container" id="24036055" visual_id="3609"><math alttext="=" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo></semantics></math></span>, <span class="math-container" id="24036056" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span>, which are sometimes brought up as having different meanings. Maybe these different meanings are key to my question.</p>
</div>
<hr/>
<div id="tags">
<span> logic </span><span> first-order-logic </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="5366936"> Abbreviations can be considered as "shorthands" in metatheory or as definitional extensions of the language. </td></tr><tr><td comment_id="5366942"> You can see the answer to the post [semantics-and-logical-structure-in-definitions](https://math.stackexchange.com/questions/820673/semantics-and-logical-structure-in-definitions) as well as the post [are-if-and-iff-interchangeable-in-definitions](https://math.stackexchange.com/questions/566565/are-if-and-iff-interchangeable-in-definitions) </td></tr><tr><td comment_id="5366950"> The case of propositional logic is not very useful, because in it we have no *equality* symbol (<span class="math-container" id="24036064" visual_id="3609"><math alttext="=" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo></semantics></math></span>). The typical case of prop logic is to start with a language based on the <span class="math-container" id="24036058" visual_id="3740703"><math alttext="\lor,\lnot" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo><mo>,</mo><mi mathvariant="normal">¬</mi></mrow></semantics></math></span> connectives and then add (in the metatheory) the new connective <span class="math-container" id="24036059" visual_id="7792"><math alttext="\to" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>→</mo></semantics></math></span> (defined through: <span class="math-container" id="24036060" visual_id="117725"><math alttext="P\to Q" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow></semantics></math></span> in place of the primitive <span class="math-container" id="24036061" visual_id="68150"><math alttext="\lnot P\lor Q" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">¬</mi><mo>⁢</mo><mi>P</mi></mrow><mo>∨</mo><mi>Q</mi></mrow></semantics></math></span>). </td></tr><tr><td comment_id="5367007"> With regards to your note at the end, while <span class="math-container" id="24036062" visual_id="49997"><math alttext="\vdash" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊢</mo></semantics></math></span> is commonly used for syntactic provability and <span class="math-container" id="24036063" visual_id="1014"><math alttext="\vDash" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><merror class="ltx_ERROR undefined undefined"><mtext>\vDash</mtext></merror></semantics></math></span> is commonly used for semantic satisfiability, both of these may be used in different ways. Similarly, all the other operators you list are sometimes used for the same concept, more often stand for different concepts but some authors may use them in opposite ways. Generally, you will need to see how some notation is defined. Common conventions vary field to field and author to author. You cannot rely on how you saw it used somewhere else. </td></tr><tr><td comment_id="5367639"> Regarding the meaning of symbols, see [implies-vs-entails-vs-provable](https://math.stackexchange.com/questions/286077/implies-vs-entails-vs-provable) </td></tr><tr><td comment_id="5368271"> In addition to Derek Elkins answer the links and references therein provided by  Mauro ALLEGRANZA were very helpful in answering this question. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="2599328" id="answer">
<p>As Mauro ALLEGRANZA said, the most common way to deal with this problem in the context of first-order logic and similar systems is to handle it entirely metalogically.</p> <p>For example, if we are working in a first-order logic without equality in which we've formalized the ZFC axioms say, then we can define a new binary relation symbol which we'll write as <span class="math-container" id="24036064" visual_id="3609"><math alttext="=" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo></semantics></math></span> and add a new axiom that states <span class="math-container" id="24036065" visual_id="3740704"><math alttext="\forall X,Y.X=Y\iff(\forall x.x\in X\iff x\in Y)\land(\forall Z.X\in Z\iff Y% \in Z)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo>.</mo><mi>X</mi><mo>=</mo><mi>Y</mi><mo>⇔</mo><mrow><mo stretchy="false">(</mo><mo>∀</mo><mi>x</mi><mo>.</mo><mi>x</mi><mo>∈</mo><mi>X</mi><mo>⇔</mo><mi>x</mi><mo>∈</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mo>∧</mo><mrow><mo stretchy="false">(</mo><mo>∀</mo><mi>Z</mi><mo>.</mo><mi>X</mi><mo>∈</mo><mi>Z</mi><mo>⇔</mo><mi>Y</mi><mo>∈</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span></p> <p>This produces a <em>new</em> first-order theory, call it ZFC', that has in addition to this relation symbol and axiom, all the function, relation symbols, and axioms of ZFC. As Mauro ALLEGRANZA states, this is called <a href="https://en.wikipedia.org/wiki/Extension_by_definitions" rel="nofollow noreferrer">extension by definition</a>.</p> <p>You can additionally prove, metalogically by induction over all formulas, that for <em>every</em> formula <span class="math-container" id="24036066" visual_id="252"><math alttext="\varphi" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi></semantics></math></span>, if <span class="math-container" id="24036067" visual_id="3940"><math alttext="x=y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></semantics></math></span> then <span class="math-container" id="24036068" visual_id="3740705"><math alttext="\varphi(x)\iff\varphi(y)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>φ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>⇔</mo><mrow><mi>φ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. This is called <a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles" rel="nofollow noreferrer">indiscernibility of identicals</a>. This shows that it would be admissible to add as a rule of logic a rule that, in a single step, let you replace <span class="math-container" id="24036069" visual_id="67"><math alttext="x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi></semantics></math></span> with <span class="math-container" id="24036070" visual_id="68"><math alttext="y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi></semantics></math></span> in any formula if you had proven <span class="math-container" id="24036071" visual_id="3940"><math alttext="x=y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></semantics></math></span>. Indeed, first-order logic <em>with</em> equality has such a rule for the built-in notion of equality, and if you formulated ZFC in this logic you'd likely have the above axiom as well, only in this context it wouldn't be a definition but instead a quite significant statement that could lead to inconsistency if you made a mistake.</p> <p>Indiscernibility of identicals gives you the "one-step" proof rule you desire as far as introducing new terms, i.e. new function symbols and constants. Often proof systems don't have an equivalent for logical equivalence. This is usually because there is no way in the object language to talk about formulas parameterized by propositional variables. (In higher-order logics, we can, though in some higher-order logics there isn't a distinction between predicates and terms, so the indiscernibility of identicals handles both cases.) We can prove, metalogically, that logical equivalence is a congruence with respect to the logical connectives and this warrants replacing subformulas with their logical equivalents. This operation is extremely common when informally reasoning about both formal and informal statements.</p> <p>A notion of definition in the object language is more common in programming languages and the languages used by proof assistants which are often based on some form of type theory. (For many proof assistants, the interface is actually a programming language which then serves as the meta-language [that's what ML in <a href="https://www.smlnj.org/sml97.html" rel="nofollow noreferrer">SML</a> stands for], and so the definition facilities of the host language are used to handle such abbreviations.) These languages are very often higher-order and support a notion of local definition which would be a bit awkward to deal with in a first-order language. An example is the <code>let</code> terms in the <a href="https://coq.inria.fr/refman/cic.html" rel="nofollow noreferrer">Calculus of Inductive Constructions</a> which is the core language of <a href="https://coq.inria.fr/" rel="nofollow noreferrer">Coq</a>. Many type theories and programming languages are lambda calculi where a simple form of local definition can be defined via the (metalogical) abbreviation of <span class="math-container" id="24036072" visual_id="3740706"><math alttext="(\mathsf{let}\ x=t\ \mathsf{in}\ E):=((\lambda x.E)t)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">(</mo><mpadded width="+5pt"><mi>𝗅𝖾𝗍</mi></mpadded><mi>x</mi><mo>=</mo><mpadded width="+5pt"><mi>t</mi></mpadded><mpadded width="+5pt"><mi>𝗂𝗇</mi></mpadded><mi>E</mi><mo stretchy="false">)</mo></mrow><mo>:=</mo><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mo>.</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><mi>t</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>.</p> <p>I vaguely recall approaches to formalize a more object language notion of definition in a more first-order logic context, but I don't have any good pointers into literature of that type. As I mentioned, the programming language theory and type theory literature discusses notions of definition and definitional equality quite a bit, but this is often in a programming and/or higher-order context.</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="5368256"> This addresses the question for me! The link to extension by definition helped, however, your comment about the metalogical induction really got to the heart of what I was asking. The wikipedia article states that the conclusion holds but makes no reference to the metalogical proof. The induction proof makes sense given my second example. My intuition was that we should be able to build up the replacement rule for any formula using the fact that it clearly holds for simple formulas. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="820673"> Semantics and Logical structure in Definitions </td></tr><tr><td post_id="566565"> Are "if" and "iff" interchangeable in definitions? </td></tr><tr><td post_id="286077"> Implies vs. Entails vs. Provable </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
