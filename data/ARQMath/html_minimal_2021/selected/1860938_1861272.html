<!DOCTYPE html>

<html>
<head>
<title>Definition of Ordinals in Set Theory in Layman Terms</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Definition of Ordinals in Set Theory in Layman Terms </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="1860938">
<p>I've taken a huge interest in the mathematical concept of infinity and often been contemplating the same over years. But the fundamental concept of set theory ordinals continues to evade my understanding. The questions below comprise (more or less) the gaps in my comprehension of the mathematical infinite:</p> <ol> <li>Ordinal numbers in general (1st, 2nd, 3rd, 4th...) are entirely different from ordinal numbers in set theory, correct?</li> <li>I understand that set theory ordinals are basically sets that contain a least element by definition. But, is it necessary for the elements of an ordinal to be strictly in order? For example, must the ordinal 4 be represented as <strong><em>{</em></strong>∅, {∅}, {∅,{∅}}, {∅, {∅}, {∅,{∅}}}....<strong><em>}</em></strong> and not as <strong><em>{</em></strong>{∅,{∅}}, ∅, {∅}, {∅, {∅}, {∅,{∅}}}....<strong><em>}</em></strong>?</li> <li>The cardinality of ω is א‎0 (please correct me if I'm wrong), but where exactly is the position of ω along the number line. Is it א‎0th position (so to speak)?</li> </ol> <p>I apologize for the naivety of the questions above (honestly, I really don't find a layman explanation of ordinals anywhere on the web. I saw a very good YouTube video though). The objective is to understand the core concept of set theory ordinals (well enough to be able to explain the same to a layman) rather than memorizing formal, mathematical definitions with little to no true comprehension of the same. Thanks in advance!</p>
</div>
<hr/>
<div id="tags">
<span> elementary-set-theory </span><span> ordinals </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="3811001"> I'm 99% confident that the video of which you speak is riddled with mathematical holes, which of course lay people cannot see. Better to leave it unmentioned... </td></tr><tr><td comment_id="3811094"> Yes, I was kind of having the same thought myself :) </td></tr><tr><td comment_id="3811105"> I'm writing an explanation now that rigorously explains the intuition behind ordinals, but it will take a while. </td></tr><tr><td comment_id="3811143"> Please, please do!! Mathematics is not my favourite subject, but when I came across Georg Cantor's perspective of infinity, it blew my mind! I've been a ardent follower of the set theory representation of infinity since. At this juncture, I find it extremely disappointing that virtually nowhere on the web I'm able to find a simple, core explanation for infinite ordinals. Your explanation, I'm sure, will be a huge contribution to existing, online information on transfinite ordinals. You have my utmost gratitude. </td></tr><tr><td comment_id="3811644"> When you say <span class="math-container" id="17231560" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>th position, you are talking about an ordinal number <span class="math-container" id="17231560" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>. Since <span class="math-container" id="17231829" visual_id="9906"><math alttext="\aleph_{0}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></semantics></math></span> is not an ordinal, but rather a cardinal, talking about the <span class="math-container" id="17231829" visual_id="9906"><math alttext="\aleph_{0}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></semantics></math></span>th position along the ordinal line makes no sense. However <span class="math-container" id="17231869" visual_id="4986"><math alttext="\omega" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span> is the <span class="math-container" id="17231869" visual_id="4986"><math alttext="\omega" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span>th ordinal. </td></tr><tr><td comment_id="3811657"> @HemnathPrabagaran: There you go. It's as concise as I can make it without missing out key details. However, I personally don't subscribe to the set-theoretic notion of cardinality, because in my opinion it does not correctly capture the notion of size, but that's a different topic. </td></tr><tr><td comment_id="3811665"> @AsafKaragila: Every cardinal is an ordinal, and so <span class="math-container" id="17231829" visual_id="9906"><math alttext="\aleph_{0}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></semantics></math></span> is an ordinal too. I know that you're treating the notation as indicating some kind of typing, though, which is of course useful to make its intended meaning clearer. But you still have no choice but to write "<span class="math-container" id="17231510" visual_id="2092890"><math alttext="\aleph_{\beth_{1}}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><msub><merror class="ltx_ERROR undefined undefined"><mtext>\beth</mtext></merror><mn>1</mn></msub></msub></semantics></math></span>" where the subscript is used as an ordinal despite being cardinal notation, don't you? </td></tr><tr><td comment_id="3811674"> @user21820: That is a terrible and confusing thing to say to someone who is trying to grasp these two concepts. And no, I have a choice, I write <span class="math-container" id="17231511" visual_id="2092891"><math alttext="\aleph_{\gamma}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><mi>γ</mi></msub></semantics></math></span> where <span class="math-container" id="17231512" visual_id="485"><math alttext="\gamma" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>γ</mi></semantics></math></span> is the least ordinal such that <span class="math-container" id="17231513" visual_id="2092892"><math alttext="|\gamma|=\beth_{1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>γ</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><msub><merror class="ltx_ERROR undefined undefined"><mtext>\beth</mtext></merror><mn>1</mn></msub></mrow></semantics></math></span>. </td></tr><tr><td comment_id="3811686"> @AsafKaragila: What is confusing? Many textbooks **define** a cardinality of a set as the least ordinal equinumerous with it, exactly as I defined it. You're free to write things your way, but there's nothing wrong with using the widespread definition I've used. </td></tr><tr><td comment_id="3811696"> @user21820: No, those are either books aimed for learning set theory properly, or very bad books. The intuitive definition of cardinals and ordinals should be given via isomorphism classes of orders. But then we can argue that we can choose canonical representatives for the ordinals, which are the von Neumann ordinals; and we can use the axiom of choice to define canonical representative for cardinals. And even if you do *define* the two to be the same, these are still incredibly different contexts, and mixing them is just ***wrong*** from a pedagogical point of view. </td></tr><tr><td comment_id="3811699"> @user21820: Because do tell me, good sir, what is <span class="math-container" id="17231514" visual_id="2092893"><math alttext="{\aleph_{\aleph_{0}}}^{+}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mmultiscripts><mi mathvariant="normal">ℵ</mi><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub><none></none><none></none><mo>+</mo></mmultiscripts></semantics></math></span>? Is it <span class="math-container" id="17231515" visual_id="2092894"><math alttext="\aleph_{\aleph_{0}+1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><mrow><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn></mrow></msub></semantics></math></span>? But... but... but... <span class="math-container" id="17231516" visual_id="714036"><math alttext="\aleph_{0}+1=\aleph_{0}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn></mrow><mo>=</mo><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></mrow></semantics></math></span>. So does that mean that <span class="math-container" id="17231518" visual_id="714024"><math alttext="\aleph_{\aleph_{0}}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msub></semantics></math></span> is the last cardinal? No? Then what is the least cardinal above <span class="math-container" id="17231518" visual_id="714024"><math alttext="\aleph_{\aleph_{0}}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></msub></semantics></math></span>? How do you denote it? </td></tr><tr><td comment_id="3811704"> @user21820: The problem is that while rational, real, complex, integer and the likes of those share the same arithmetic, so there is never any confusion when I'm telling you that <span class="math-container" id="17231519" visual_id="1848657"><math alttext="x=1+2" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mrow><mn>1</mn><mo>+</mo><mn>2</mn></mrow></mrow></semantics></math></span> whether or not I'm talking about real numbers or integers; when it comes to ordinals and cardinals the two systems diverge quite significantly. And that is a great source for confusion for people who are not trained in this sort of mindset. So when someone asks for intuition, the worst thing to do is to give them confusing and overloaded symbols. </td></tr><tr><td comment_id="3811795"> @AsafKaragila: (I would move this to chat, but I know you don't use it, so I'll try to keep my response short.) I wrote my answer aiming to give an intuitive explanation for the motivation for ordinals and cardinals as well as the rigorous definitions. So my first section gives the intuitive definition of size comparison is via injections. I didn't define size as an equivalence class of equinumerous sets, because that does not allow comparison without the axiom of choice, which arguably is not what "size" connotes. </td></tr><tr><td comment_id="3811811"> @AsafKaragila: For pedagogical purpose, implicit typing is sufficient in most cases, and we do that all the time anyway. The example you bring up is not yet a case in which typing is insufficient, since <span class="math-container" id="17231520" visual_id="2092895"><math alttext="\aleph_{\aleph_{0}}^{+}=\aleph_{ω}^{+}=\aleph_{ω+1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="normal">ℵ</mi><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub><mo>+</mo></msubsup><mo>=</mo><msubsup><mi mathvariant="normal">ℵ</mi><mi>ω</mi><mo>+</mo></msubsup><mo>=</mo><msub><mi mathvariant="normal">ℵ</mi><mrow><mi>ω</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></semantics></math></span>. The last equality is valid because <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span> has the implicit type "ordinal", and your original manipulation would be considered invalid because <span class="math-container" id="17231829" visual_id="9906"><math alttext="\aleph_{0}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></semantics></math></span> has the implicit type "cardinal". In cases where implicit typing is insufficient, indeed one has to use type coercion such as via "where"-clauses. </td></tr><tr><td comment_id="3811828"> @user21820: No. That is entirely not true. Implicit typing only works when the reader is able to identify the context on their own. This is rarely the case when first encountering something. There is a reason mathematics is a slow-paced machine based on definitions and careful deductions. Sure, I'm not going to write in my paper every time I'm using ordinal or cardinal addition. But I'll be damned if I don't explicitly mention the arithmetic to my students, and they will ask me to be sure, if I didn't, forcing me to make the typing explicit. In this context, using <span class="math-container" id="17231829" visual_id="9906"><math alttext="\aleph_{0}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">ℵ</mi><mn>0</mn></msub></semantics></math></span> is a cardinal sin! </td></tr><tr><td comment_id="3811836"> @AsafKaragila: Well in my answer I totally avoided defining addition and multiplication of both ordinals and cardinals, so the divergence between ordinal and cardinal arithmetic does not cause any problem. Indeed it is a great source of confusion for beginners who don't have mathematical maturity, which is one reason I consciously avoided it in all the arguments (except the very last exercise). </td></tr><tr><td comment_id="3811860"> @AsafKaragila: As for implicit typing, I certainly agree that we should point out all the typing to students, but not that we should necessarily avoid it altogether. That said, I would only use implicit typing that is unambiguous and systematic, unlike many textbooks. In particular, I dislike the fact that "<span class="math-container" id="17231527" visual_id="54390"><math alttext="2^{ω}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>ω</mi></msup></semantics></math></span>" can mean both "functions from <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span> to <span class="math-container" id="17231822" visual_id="358"><math alttext="2" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn></semantics></math></span>" and "the ordinal <span class="math-container" id="17231527" visual_id="54390"><math alttext="2^{ω}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>ω</mi></msup></semantics></math></span>" because in many cases they cannot be syntactically disambiguated. </td></tr><tr><td comment_id="3813278"> Some older posts which might be interesting for you (and you might probably find more if your browse questions tagged tag:ordinals a bit): [Ordinals - motivation and rigor at the same time](http://math.stackexchange.com/questions/1280222/ordinals-motivation-and-rigor-at-the-same-time) or [An easy to understand definition of <span class="math-container" id="17231528" visual_id="54277"><math alttext="\omega_{1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>1</mn></msub></semantics></math></span>?](http://math.stackexchange.com/questions/956779/an-easy-to-understand-definition-of-omega-1) </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="1861272" id="answer">
<p>Counting has two purposes, namely for specifying sizes and indices. These are directly related for finite quantities, because the number of natural numbers (including <span class="math-container" id="17231529" visual_id="92"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span>) less than <span class="math-container" id="17231530" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> (before the position <span class="math-container" id="17231531" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>) is <span class="math-container" id="17231532" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>. But in set theory, when generalizing to infinite sets these two notions become different. <span class="math-container" id="17231533">\def\nn{\mathbb{N}}</span> <span class="math-container" id="17231534">\def\zz{\mathbb{Z}}</span> <span class="math-container" id="17231535">\def\qq{\mathbb{Q}}</span> <span class="math-container" id="17231536">\def\rr{\mathbb{R}}</span> <span class="math-container" id="17231537">\def\eq{\leftrightarrow}</span> <span class="math-container" id="17231538">\def\less{\smallsetminus}</span> <span class="math-container" id="17231539" visual_id="1859707"><math alttext="\phi(5)=5-1=4" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mn>5</mn><mo>-</mo><mn>1</mn></mrow><mo>=</mo><mn>4</mn></mrow></semantics></math></span></p> <h2>Sizes</h2> <p>The notion of size is extended to infinite sets in the following way. Take any two sets <span class="math-container" id="17231540" visual_id="9515"><math alttext="X,Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow></semantics></math></span>. We say that <span class="math-container" id="17231541" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> is <strong>no larger than</strong> <span class="math-container" id="17231542" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span> if we can label each element of <span class="math-container" id="17231543" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> with a unique element of <span class="math-container" id="17231544" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span>, in the sense that no two elements of <span class="math-container" id="17231545" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> are given the same label. Mathematically this labelling is called an <strong>injection</strong> from <span class="math-container" id="17231546" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> into <span class="math-container" id="17231547" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span>, and we write <span class="math-container" id="17231548">\def\inj{\hookrightarrow}</span><span class="math-container" id="17231549" visual_id="124418"><math alttext="X\inj Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\inj</mtext></merror><mo>⁢</mo><mi>Y</mi></mrow></semantics></math></span>. We say that <span class="math-container" id="17231550" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> is <strong>of the same size as</strong> <span class="math-container" id="17231551" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span> iff there is a <strong>bijection</strong> (1-to-1 correspondence) between elements of <span class="math-container" id="17231552" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> and elements of <span class="math-container" id="17231553" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span>, and we write <span class="math-container" id="17231554" visual_id="593636"><math alttext="X\approx Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≈</mo><mi>Y</mi></mrow></semantics></math></span>. It turns out that if <span class="math-container" id="17231555" visual_id="124418"><math alttext="X\inj Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\inj</mtext></merror><mo>⁢</mo><mi>Y</mi></mrow></semantics></math></span> and <span class="math-container" id="17231556" visual_id="67014"><math alttext="Y\inj X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\inj</mtext></merror><mo>⁢</mo><mi>X</mi></mrow></semantics></math></span> then <span class="math-container" id="17231557" visual_id="593636"><math alttext="X\approx Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≈</mo><mi>Y</mi></mrow></semantics></math></span>.</p> <p>Notice that <span class="math-container" id="17231558" visual_id="2092897"><math alttext="\nn_{&amp;gt;0}\inj\nn" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><merror class="ltx_ERROR undefined undefined"><mtext>\nn</mtext></merror><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mn>0</mn></mrow></msub><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\inj</mtext></merror><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\nn</mtext></merror></mrow></semantics></math></span> via the identity labelling, and <span class="math-container" id="17231559" visual_id="2092898"><math alttext="\nn\inj\nn_{&amp;gt;0}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><merror class="ltx_ERROR undefined undefined"><mtext>\nn</mtext></merror><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\inj</mtext></merror><mo>⁢</mo><msub><merror class="ltx_ERROR undefined undefined"><mtext>\nn</mtext></merror><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mn>0</mn></mrow></msub></mrow></semantics></math></span> by labelling each element <span class="math-container" id="17231560" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> of <span class="math-container" id="17231561" visual_id="1014"><math alttext="\nn" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><merror class="ltx_ERROR undefined undefined"><mtext>\nn</mtext></merror></semantics></math></span> by <span class="math-container" id="17231562" visual_id="2324"><math alttext="n+1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></semantics></math></span>. So <span class="math-container" id="17231563" visual_id="2092899"><math alttext="\nn_{&amp;gt;0}\approx\nn" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><merror class="ltx_ERROR undefined undefined"><mtext>\nn</mtext></merror><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>g</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mn>0</mn></mrow></msub><mo>≈</mo><merror class="ltx_ERROR undefined undefined"><mtext>\nn</mtext></merror></mrow></semantics></math></span>, meaning that they cannot be distinguished in terms of size as defined above. There is no other elegant way to define size comparison to distinguish them, because we want it to be independent of labelling, meaning that we want <span class="math-container" id="17231564" visual_id="2092900"><math alttext="X\approx\{f(x):x\in X\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≈</mo><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>x</mi><mo>∈</mo><mi>X</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span> for any set <span class="math-container" id="17231565" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> and function <span class="math-container" id="17231566" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> on <span class="math-container" id="17231567" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>.</p> <h2>Indices</h2> <p>The notion of indexing, on the other hand, can be extended in the following way. Indexing is used for a sequence, where order is important. Note that a sequence is nothing more than a function on its indices, where the indices are totally ordered. But if we want to define a sequence recursively by defining each element in terms of all the previous ones, then it is in general not enough for indices to be ordered. Specifically, a <strong>recursive definition</strong> on <span class="math-container" id="17231568" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> is a function <span class="math-container" id="17231569" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> such that, for every <span class="math-container" id="17231570" visual_id="158"><math alttext="i" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi></semantics></math></span> in <span class="math-container" id="17231571" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> and function <span class="math-container" id="17231572" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> on <span class="math-container" id="17231573" visual_id="2092901"><math alttext="I_{&amp;lt;i}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></semantics></math></span>, <span class="math-container" id="17231574" visual_id="363581"><math alttext="E(f)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> is a function on <span class="math-container" id="17231575" visual_id="2092902"><math alttext="I_{\leq i}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mrow><mi></mi><mo>≤</mo><mi>i</mi></mrow></msub></semantics></math></span>, and we want to build a function <span class="math-container" id="17231576" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> on <span class="math-container" id="17231577" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> such that <span class="math-container" id="17231578" visual_id="2092903"><math alttext="f\restriction I_{\leq i}=E(f\restriction I_{&amp;lt;i})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\restriction</mtext></merror><mo>⁢</mo><msub><mi>I</mi><mrow><mi></mi><mo>≤</mo><mi>i</mi></mrow></msub></mrow><mo>=</mo><mrow><mi>E</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\restriction</mtext></merror><mo>⁢</mo><msub><mi>I</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> for any <span class="math-container" id="17231579" visual_id="1367"><math alttext="i\in I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></semantics></math></span> ("<span class="math-container" id="17231580" visual_id="2092904"><math alttext="f\restriction D" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\restriction</mtext></merror><mo>⁢</mo><mi>D</mi></mrow></semantics></math></span>" denotes "<span class="math-container" id="17231581" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> restricted to the domain <span class="math-container" id="17231582" visual_id="524"><math alttext="D" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi></semantics></math></span>"). We cannot always do this if <span class="math-container" id="17231583" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> has a strictly decreasing infinite sequence. For a concrete example, there is no function <span class="math-container" id="17231584" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> on <span class="math-container" id="17231585" visual_id="1014"><math alttext="\zz" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><merror class="ltx_ERROR undefined undefined"><mtext>\zz</mtext></merror></semantics></math></span> such that <span class="math-container" id="17231586" visual_id="2092905"><math alttext="f(r)=\begin{cases}\end{cases}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mo>{</mo></mrow></semantics></math></span>\exists s \in \zz_{&lt;r}\ ( f(s)=1 )<span class="math-container" id="17231587" visual_id="2092906"><math alttext="\\ 1&amp;amp;otherwise" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mn>1</mn><mo>⁢</mo><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>a</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>p</mi></mrow><mo>;</mo><mrow><mi>o</mi><mo>⁢</mo><mi>t</mi><mo>⁢</mo><mi>h</mi><mo>⁢</mo><mi>e</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>w</mi><mo>⁢</mo><mi>i</mi><mo>⁢</mo><mi>s</mi><mo>⁢</mo><mi>e</mi></mrow></mrow></semantics></math></span>, despite it looking like a recursive definition. (Exercise: Prove that no such <span class="math-container" id="17231588" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> exists!) Notice that this counter-example can be easily adapted to any <span class="math-container" id="17231589" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> that has some strictly decreasing infinite sequence.</p> <p>It turns out that, if <span class="math-container" id="17231590" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> has no strictly decreasing infinite sequence, then every recursive definition on <span class="math-container" id="17231591" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> not only will have some sequence satisfying it (in the above sense) but also that sequence is in fact unique! We say that a total order is <strong>well-ordered</strong> iff if every non-empty set of elements in it has a minimum. Now given any such <span class="math-container" id="17231592" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> and any set <span class="math-container" id="17231593" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> of elements in <span class="math-container" id="17231594" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span>, if <span class="math-container" id="17231595" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> has no minimum then we can iteratively pick a (countable) strictly decreasing sequence of elements in <span class="math-container" id="17231596" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> [by the axiom of dependent choice]. Therefore <span class="math-container" id="17231597" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> is well-ordered. Now take any recursive definition <span class="math-container" id="17231598" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> on <span class="math-container" id="17231599" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span>. If <span class="math-container" id="17231600" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> does not 'work', namely it does not uniquely define a sequence on <span class="math-container" id="17231601" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span>, then let <span class="math-container" id="17231602" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> be the set of all elements <span class="math-container" id="17231603" visual_id="158"><math alttext="i" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi></semantics></math></span> in <span class="math-container" id="17231604" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> such that there is no unique function <span class="math-container" id="17231605" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> on <span class="math-container" id="17231606" visual_id="2092902"><math alttext="I_{\leq i}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mrow><mi></mi><mo>≤</mo><mi>i</mi></mrow></msub></semantics></math></span> such that <span class="math-container" id="17231607" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> agrees <span class="math-container" id="17231608" visual_id="2092907"><math alttext="\int_{\infty}^{p}e^{\frac{-1}{u^{2}}}du" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo largeop="true" symmetric="true">∫</mo><mi mathvariant="normal">∞</mi><mi>p</mi></msubsup><mrow><msup><mi>e</mi><mfrac><mrow><mo>-</mo><mn>1</mn></mrow><msup><mi>u</mi><mn>2</mn></msup></mfrac></msup><mo>⁢</mo><mrow><mo rspace="0pt">𝑑</mo><mi>u</mi></mrow></mrow></mrow></semantics></math></span>, and let <span class="math-container" id="17231609" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span> be the minimum of <span class="math-container" id="17231610" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> in <span class="math-container" id="17231611" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span>. Then for every <span class="math-container" id="17231612" visual_id="2092908"><math alttext="i\in I_{&amp;lt;m}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><msub><mi>I</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>m</mi></mrow></msub></mrow></semantics></math></span> there is a unique function on <span class="math-container" id="17231613" visual_id="2092902"><math alttext="I_{\leq i}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mrow><mi></mi><mo>≤</mo><mi>i</mi></mrow></msub></semantics></math></span> satisfying <span class="math-container" id="17231614" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span>, and all these functions agree, and hence combining them gives a unique function on <span class="math-container" id="17231615" visual_id="2092909"><math alttext="I_{&amp;lt;m}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>m</mi></mrow></msub></semantics></math></span> that satisfies <span class="math-container" id="17231616" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span>. By definition of <span class="math-container" id="17231617" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> there is a unique function on <span class="math-container" id="17231618" visual_id="2092910"><math alttext="I_{\leq m}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mrow><mi></mi><mo>≤</mo><mi>m</mi></mrow></msub></semantics></math></span> that satisfies <span class="math-container" id="17231619" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span>, contradicting the definition of <span class="math-container" id="17231620" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span>. Therefore <span class="math-container" id="17231621" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> does 'work', namely there is a unique sequence on <span class="math-container" id="17231622" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> that satisfies <span class="math-container" id="17231623" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span>.</p> <p>[Note: If you do not want to use the axiom of dependent choice, then you can still have recursive definitions for well-orders.]</p> <p>The above is why we use well-orders for indexing, since every well-order has no strictly decreasing infinite sequence. In textbooks <span class="math-container" id="17231624" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> is also called an <strong>extender function</strong> because it essentially allows us to extend the partial sequence of all previous terms to the current term. [Technically <span class="math-container" id="17231625" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> is not an object in most set theories, but we always use <span class="math-container" id="17231626" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> as a function and so we can still apply the above argument to any specific defining formula for <span class="math-container" id="17231627" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span> without constructing <span class="math-container" id="17231628" visual_id="777"><math alttext="E" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi></semantics></math></span>.] Also, the above proof technique generalizes to <strong>transfinite induction</strong>, which is that for any well-order <span class="math-container" id="17231629" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> and statement <span class="math-container" id="17231630" visual_id="318"><math alttext="P" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi></semantics></math></span> we can prove <span class="math-container" id="17231631" visual_id="2092911"><math alttext="\forall i\in I\ (\forall j\in I_{&amp;lt;i}\ (P(j))\to P(i))\to\forall i\in I\ (P(% i))" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>i</mi><mo>∈</mo><mpadded width="+5pt"><mi>I</mi></mpadded><mrow><mo stretchy="false">(</mo><mo>∀</mo><mi>j</mi><mo>∈</mo><mpadded width="+5pt"><msub><mi>I</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></mpadded><mrow><mo stretchy="false">(</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo>→</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo>→</mo><mo>∀</mo><mi>i</mi><mo>∈</mo><mpadded width="+5pt"><mi>I</mi></mpadded><mrow><mo stretchy="false">(</mo><mi>P</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>.</p> <h2>Ordinals</h2> <p>Given any two total orders <span class="math-container" id="17231632" visual_id="9515"><math alttext="X,Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>,</mo><mi>Y</mi></mrow></semantics></math></span>, we say that <span class="math-container" id="17231633" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> <strong>embeds</strong> into <span class="math-container" id="17231634" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span> if there is an injection <span class="math-container" id="17231635" visual_id="252"><math alttext="φ" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi></semantics></math></span> from <span class="math-container" id="17231636" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> into <span class="math-container" id="17231637" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span> that preserves the ordering, meaning that <span class="math-container" id="17231638" visual_id="2092912"><math alttext="a&amp;lt;b\eq φ(a)&amp;lt;φ(b)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>a</mi><mo>&lt;</mo></mrow><mrow><mi>b</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\eq</mtext></merror><mo>⁢</mo><mi>φ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mo>&lt;</mo></mrow><mrow><mi>φ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> for every <span class="math-container" id="17231639" visual_id="249"><math alttext="a,b" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow></semantics></math></span> in <span class="math-container" id="17231640" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>. Also, we say that <span class="math-container" id="17231641" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> is <strong>isomorphic</strong> to <span class="math-container" id="17231642" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span> if there is a bijection from <span class="math-container" id="17231643" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> to <span class="math-container" id="17231644" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span> that preserves the ordering. It is not too hard to prove that, for any two non-isomorphic well-orders, one of them embeds into the other, and not the other way around. Therefore well-orders are themselves totally ordered up to isomorphism, meaning that they satisfy the conditions for a total order except that equality is replaced by isomorphism.</p> <p>Now the next natural step is to find a canonical form for well-orders, which we shall call <strong>ordinals</strong>. Take any well-order <span class="math-container" id="17231645" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>. Recursively define the sequence <span class="math-container" id="17231646" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> on <span class="math-container" id="17231647" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> by <span class="math-container" id="17231648" visual_id="2092913"><math alttext="f(i)=\{f(j):j\in X_{&amp;lt;i}\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>j</mi><mo>∈</mo><msub><mi>X</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span> for each <span class="math-container" id="17231649" visual_id="250087"><math alttext="i\in X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>X</mi></mrow></semantics></math></span>. Then its range <span class="math-container" id="17231650" visual_id="2092914"><math alttext="\{f(i):i\in X\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>i</mi><mo>∈</mo><mi>X</mi></mrow><mo stretchy="false">}</mo></mrow></semantics></math></span> ordered under set membership <span class="math-container" id="17231651" visual_id="824"><math alttext="\in" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∈</mo></semantics></math></span> is isomorphic to <span class="math-container" id="17231652" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>! (Exercise: Prove this by using transfinite induction to prove simultaneously that <span class="math-container" id="17231653" visual_id="2092915"><math alttext="\{f(j):j\in X_{\leq i}\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>j</mi><mo>∈</mo><msub><mi>X</mi><mrow><mi></mi><mo>≤</mo><mi>i</mi></mrow></msub></mrow><mo stretchy="false">}</mo></mrow></semantics></math></span> and <span class="math-container" id="17231654" visual_id="3491"><math alttext="f(i)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> are well-ordered under <span class="math-container" id="17231655" visual_id="824"><math alttext="\in" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∈</mo></semantics></math></span> for every <span class="math-container" id="17231656" visual_id="158"><math alttext="i" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi></semantics></math></span> in <span class="math-container" id="17231657" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>.) We use this well-ordering as the (canonical) ordinal for <span class="math-container" id="17231658" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>, which we shall denote by <span class="math-container" id="17231659" visual_id="2092916"><math alttext="ord(X)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>. We will also order ordinals by <span class="math-container" id="17231660" visual_id="824"><math alttext="\in" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∈</mo></semantics></math></span> unless otherwise stated.</p> <p>This also can motivate the von Neumann definition of ordinals as sets that are transitive (every element is a subset) and well-ordered under <span class="math-container" id="17231661" visual_id="824"><math alttext="\in" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∈</mo></semantics></math></span>. It turns out that every (canonical) ordinal is also a von Neumann ordinal, and every von Neumann ordinal is its own (canonical) ordinal. (Exercise: Prove this. For the first part, first prove by transfinite induction that <span class="math-container" id="17231662" visual_id="3491"><math alttext="f(i)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> is a von Neumann ordinal for every <span class="math-container" id="17231663" visual_id="158"><math alttext="i" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi></semantics></math></span> in <span class="math-container" id="17231664" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>.)</p> <p>Note that no ordinal is an element of itself, otherwise it will have a strictly decreasing infinite sequence. Consequently, there cannot be a set of ordinals <span class="math-container" id="17231665" visual_id="464083"><math alttext="ORD" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>D</mi></mrow></semantics></math></span> in most set theories, because <span class="math-container" id="17231666" visual_id="464083"><math alttext="ORD" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>D</mi></mrow></semantics></math></span> would be a von Neumann ordinal and hence <span class="math-container" id="17231667" visual_id="2092917"><math alttext="ORD\in ORD" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>O</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>D</mi></mrow><mo>∈</mo><mrow><mi>O</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>D</mi></mrow></mrow></semantics></math></span>.</p> <h2>Cardinals</h2> <p>Now we go back to the notion of size. It turns out that we can use some of the ordinals to represent the sizes of infinite sets. Take any set <span class="math-container" id="17231668" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>. Let <span class="math-container" id="17231669" visual_id="304"><math alttext="W" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi></semantics></math></span> be the set of all well-orders with elements in <span class="math-container" id="17231670" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>, and let <span class="math-container" id="17231671" visual_id="2092918"><math alttext="A=\{ord(w):w\in W\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>o</mi><mo>⁢</mo><mi>r</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>w</mi><mo>∈</mo><mi>W</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span>. Then we can prove that <span class="math-container" id="17231672" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span> is a von Neumann ordinal. Also there cannot be an injection <span class="math-container" id="17231673" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> from <span class="math-container" id="17231674" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span> into <span class="math-container" id="17231675" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>, otherwise we can define a well-order <span class="math-container" id="17231676" visual_id="4197"><math alttext="&amp;lt;" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo></mrow></semantics></math></span> on <span class="math-container" id="17231677" visual_id="2092919"><math alttext="S=\{f(a):a\in A\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span> by <span class="math-container" id="17231678" visual_id="2092920"><math alttext="f(a)&amp;lt;f(b)\eq a\in b" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mo>&lt;</mo></mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\eq</mtext></merror><mo>⁢</mo><mi>a</mi></mrow></mrow><mo>∈</mo><mi>b</mi></mrow></semantics></math></span>, and then <span class="math-container" id="17231679" visual_id="2092921"><math alttext="A=ord(S,&amp;lt;)\in A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>o</mi><mi>r</mi><mi>d</mi><mrow><mo stretchy="false">(</mo><mi>S</mi><mo>,</mo><mi mathvariant="normal">&amp;</mi><mi>l</mi><mi>t</mi><mo>;</mo><mo stretchy="false">)</mo></mrow><mo>∈</mo><mi>A</mi></mrow></semantics></math></span>.</p> <p>Given the full axiom of choice, we can prove that <span class="math-container" id="17231680" visual_id="2092922"><math alttext="X\approx A_{&amp;lt;i}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>≈</mo><msub><mi>A</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></mrow></semantics></math></span> for some <span class="math-container" id="17231681" visual_id="54211"><math alttext="i\in A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>A</mi></mrow></semantics></math></span> as follows. Recursively define <span class="math-container" id="17231682" visual_id="3491"><math alttext="f(i)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> to be some element in <span class="math-container" id="17231683" visual_id="2092923"><math alttext="X\less\{f(j):j\in A_{&amp;lt;i}\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\less</mtext></merror><mo>⁢</mo><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>j</mi><mo>∈</mo><msub><mi>A</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span> if there is one and <span class="math-container" id="17231684" visual_id="1014"><math alttext="\none" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><merror class="ltx_ERROR undefined undefined"><mtext>\none</mtext></merror></semantics></math></span> otherwise, for each <span class="math-container" id="17231685" visual_id="54211"><math alttext="i\in A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>A</mi></mrow></semantics></math></span>. By definition of <span class="math-container" id="17231686" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>, <span class="math-container" id="17231687" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> is not an injection from <span class="math-container" id="17231688" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span> into <span class="math-container" id="17231689" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>, and hence there is a least <span class="math-container" id="17231690" visual_id="54211"><math alttext="i\in A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>A</mi></mrow></semantics></math></span> such that <span class="math-container" id="17231691" visual_id="2092923"><math alttext="X\less\{f(j):j\in A_{&amp;lt;i}\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\less</mtext></merror><mo>⁢</mo><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>j</mi><mo>∈</mo><msub><mi>A</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span> is empty, which implies that <span class="math-container" id="17231692" visual_id="2092924"><math alttext="f\restriction A_{&amp;lt;i}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\restriction</mtext></merror><mo>⁢</mo><msub><mi>A</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></mrow></semantics></math></span> is an bijection between <span class="math-container" id="17231693" visual_id="2092925"><math alttext="A_{&amp;lt;i}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mrow><mrow><mi mathvariant="normal">&amp;</mi><mo>⁢</mo><mi>l</mi><mo>⁢</mo><mi>t</mi></mrow><mo>;</mo><mi>i</mi></mrow></msub></semantics></math></span> and <span class="math-container" id="17231694" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>. By the well-ordering of ordinals we can define <span class="math-container" id="17231695" visual_id="1514527"><math alttext="\#(X)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, the <strong>cardinality</strong> of <span class="math-container" id="17231696" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>, to be the least ordinal such that there is a bijection between <span class="math-container" id="17231697" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> and it. [Without the axiom of choice, we cannot define <span class="math-container" id="17231698" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> and so this definition of cardinality fails, but by the well-ordering of ordinals there is a least ordinal <span class="math-container" id="17231699" visual_id="1116"><math alttext="H" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi></semantics></math></span>, called a Hartogs number, such that there is no injection from <span class="math-container" id="17231700" visual_id="1116"><math alttext="H" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi></semantics></math></span> into <span class="math-container" id="17231701" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>, which is also a sort of measure of size.]</p> <p>The size condition allows us to define recursive sequences on <span class="math-container" id="17231702" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> by ordering its elements according to this well-order. The minimality condition ensures that the partial sequence that we have to extend in the recursive definition is strictly smaller than <span class="math-container" id="17231703" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>, which condition may be needed by the recursive definition itself.</p> <p>For instance we can prove that <span class="math-container" id="17231704" visual_id="2092926"><math alttext="\#(S^{2})=\#(S)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>S</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> for any infinite set <span class="math-container" id="17231705" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> by transfinite induction. Let <span class="math-container" id="17231706" visual_id="2092927"><math alttext="k=\#(S)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. Then it suffices to prove that <span class="math-container" id="17231707" visual_id="2092928"><math alttext="\#(k^{2})=k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>k</mi></mrow></semantics></math></span>. Order the elements of <span class="math-container" id="17231708" visual_id="1619"><math alttext="k^{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>k</mi><mn>2</mn></msup></semantics></math></span> by maximum and then lexicographic order, which can be easily shown to be a well-order. Let <span class="math-container" id="17231709" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span> be the ordinal for this well-order, and let <span class="math-container" id="17231710" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> be the isomorphism from <span class="math-container" id="17231711" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span> to <span class="math-container" id="17231712" visual_id="1619"><math alttext="k^{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>k</mi><mn>2</mn></msup></semantics></math></span>. If <span class="math-container" id="17231713" visual_id="28776"><math alttext="k&amp;lt;m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>k</mi><mo>&lt;</mo></mrow><mi>m</mi></mrow></semantics></math></span>, then let <span class="math-container" id="17231714" visual_id="413433"><math alttext="a,b\in k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><mo>∈</mo><mi>k</mi></mrow></semantics></math></span> such that <span class="math-container" id="17231715" visual_id="2092929"><math alttext="f(k)=(a,b)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, and let <span class="math-container" id="17231716" visual_id="2092930"><math alttext="d=\#(\max(a,b))\leq\max(a,b)&amp;lt;k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>d</mi><mo>=</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>≤</mo><mrow><mrow><mi>max</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&lt;</mo></mrow></mrow><mi>k</mi></mrow></semantics></math></span>. Then <span class="math-container" id="17231717" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span> is isomorphic to <span class="math-container" id="17231718" visual_id="2092931"><math alttext="\{f(i):i\in k\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mi>i</mi><mo>∈</mo><mi>k</mi></mrow><mo stretchy="false">}</mo></mrow></semantics></math></span> <span class="math-container" id="17231719" visual_id="2092932"><math alttext="\subseteq\{(x,y):x,y\in k\land x,y\leq d\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi></mi><mo>⊆</mo><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mo>:</mo><mrow><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>∈</mo><mrow><mi>k</mi><mo>∧</mo><mi>x</mi></mrow></mrow><mo>,</mo><mrow><mi>y</mi><mo>≤</mo><mi>d</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span> <span class="math-container" id="17231720" visual_id="2092933"><math alttext="\approx\#((d⊕1)^{2})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi></mi><mo>≈</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> <span class="math-container" id="17231721" visual_id="2092934"><math alttext="=\#(d^{2}⊕d⊕d⊕1)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi></mi><mo>=</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> <span class="math-container" id="17231722" visual_id="2092935"><math alttext="=\#(d⊕d⊕d⊕1)&amp;lt;k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi></mi><mo>=</mo><mrow><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><mo>&lt;</mo></mrow><mi>k</mi></mrow></mrow></semantics></math></span>, where "<span class="math-container" id="17231723" visual_id="2092936"><math alttext="p⊕q" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>q</mi></mrow></semantics></math></span>" denotes a disjoint union of <span class="math-container" id="17231724" visual_id="74"><math alttext="p" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi></semantics></math></span> and <span class="math-container" id="17231725" visual_id="625"><math alttext="q" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi></semantics></math></span>, namely <span class="math-container" id="17231726" visual_id="2092937"><math alttext="\{(0,x):x\in p\}\cup\{(1,x):x\in q\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>:</mo><mrow><mi>x</mi><mo>∈</mo><mi>p</mi></mrow><mo stretchy="false">}</mo></mrow><mo>∪</mo><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>:</mo><mrow><mi>x</mi><mo>∈</mo><mi>q</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span>. The last inequality is because <span class="math-container" id="17231727" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span> is infinite, and either <span class="math-container" id="17231728" visual_id="302"><math alttext="d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi></semantics></math></span> is finite and so <span class="math-container" id="17231729" visual_id="2092938"><math alttext="d⊕d⊕d⊕1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mn>1</mn></mrow></semantics></math></span> is also finite, or <span class="math-container" id="17231730" visual_id="302"><math alttext="d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi></semantics></math></span> is infinite and so <span class="math-container" id="17231731" visual_id="2092939"><math alttext="\#(d⊕d⊕d⊕1)=d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>d</mi></mrow></semantics></math></span>. Thus <span class="math-container" id="17231732" visual_id="2092940"><math alttext="\#(k)&amp;lt;k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><mo>&lt;</mo></mrow><mi>k</mi></mrow></semantics></math></span>, contradicting the definition of <span class="math-container" id="17231733" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span>. Therefore <span class="math-container" id="17231734" visual_id="2092941"><math alttext="k\geq m\geq\#(k^{2})\geq\#(k)=k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≥</mo><mi>m</mi><mo>≥</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><mo>≥</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>k</mi></mrow></semantics></math></span>, and hence <span class="math-container" id="17231735" visual_id="2092928"><math alttext="\#(k^{2})=k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msup><mi>k</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>k</mi></mrow></semantics></math></span>.</p> <p>(Exercise: Prove that there is a set <span class="math-container" id="17231736" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> of points in the plane such that every line passes through exactly two points in <span class="math-container" id="17231737" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span>. Sketch: Let <span class="math-container" id="17231738" visual_id="2092942"><math alttext="c=\#(\rr)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><merror class="ltx_ERROR undefined undefined"><mtext>\rr</mtext></merror><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. Then there are <span class="math-container" id="17231739" visual_id="2092943"><math alttext="\#(\rr^{2}⊕\rr)=c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">#</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msup><merror class="ltx_ERROR undefined undefined"><mtext>\rr</mtext></merror><mn>2</mn></msup><mo>⁢</mo><mi mathvariant="normal">⊕</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\rr</mtext></merror></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>c</mi></mrow></semantics></math></span> many lines in the plane. We start with <span class="math-container" id="17231740" visual_id="28587"><math alttext="S=\none" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><merror class="ltx_ERROR undefined undefined"><mtext>\none</mtext></merror></mrow></semantics></math></span> and iterate through the lines indexed by <span class="math-container" id="17231741" visual_id="146"><math alttext="c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi></semantics></math></span>. We maintain the invariance that at each step <span class="math-container" id="17231742" visual_id="2092944"><math alttext="i\in c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>c</mi></mrow></semantics></math></span> there are at most <span class="math-container" id="17231743" visual_id="27164"><math alttext="2i" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⁢</mo><mi>i</mi></mrow></semantics></math></span> many points added so far, which means that there are at most <span class="math-container" id="17231744" visual_id="2044578"><math alttext="(2i)^{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="false">(</mo><mrow><mn>2</mn><mo>⁢</mo><mi>i</mi></mrow><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></semantics></math></span> points on the current line <span class="math-container" id="17231745" visual_id="580"><math alttext="L" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi></semantics></math></span> that cannot be added to <span class="math-container" id="17231746" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> without violating the desired property. But <span class="math-container" id="17231747" visual_id="2092945"><math alttext="(2i)^{2}+2&amp;lt;c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mrow><mo stretchy="false">(</mo><mrow><mn>2</mn><mo>⁢</mo><mi>i</mi></mrow><mo stretchy="false">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mrow><mn>2</mn><mo>&lt;</mo></mrow></mrow><mi>c</mi></mrow></semantics></math></span> and <span class="math-container" id="17231748" visual_id="580"><math alttext="L" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi></semantics></math></span> passes through <span class="math-container" id="17231749" visual_id="146"><math alttext="c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi></semantics></math></span> many points, so we can add (up to two) points to <span class="math-container" id="17231750" visual_id="403"><math alttext="S" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi></semantics></math></span> such that <span class="math-container" id="17231751" visual_id="580"><math alttext="L" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi></semantics></math></span> passes through exactly two points without violating the desired property.)</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="3811677"> Anyway to answer your questions: (1) It turns out that the von Neumann construction of a model of Peano Arithmetic in ZFC is the ordinal <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span>, which is the set of all finite ordinals, with addition and multiplication defined on it by induction. So in that sense the 'ordinary' numerical ordinals are indeed set-theoretic ordinals too! (2) A set has elements but no order. It so happens that the elements of an ordinal are ordered under <span class="math-container" id="17231789" visual_id="824"><math alttext="\in" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∈</mo></semantics></math></span>, but that does not mean that the set has order to its elements by itself! </td></tr><tr><td comment_id="3811682"> (3) There is no number line in set theory. But imagine <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span> as a set of dots going off to the right, itself denoted by a dot after them all. The position of an ordinal in <span class="math-container" id="17231755" visual_id="464083"><math alttext="ORD" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo>⁢</mo><mi>R</mi><mo>⁢</mo><mi>D</mi></mrow></semantics></math></span> is itself. </td></tr><tr><td comment_id="3812862"> If that's as simple as you can put it, thank you. I'm beginning to feel I should've first brushed up on set theory language and symbolic representations (which I hardly remember any more as I first learned them way back in elementary school) before I troubled the good folks here with layman-level questioning. </td></tr><tr><td comment_id="3813136"> @HemnathPrabagaran: Yes it is difficult to understand the need for ordinals unless you need such kind of (transfinite) recursion/induction. If all you want to deal with is natural numbers and sets of them, then almost always you don't need anything more than ordinary induction. I think it's fine if you don't get the technical details (especially those in square-brackets, which are meant for advanced readers). However, perhaps the key idea that you can take away is that strong induction expressed using only ordering extends to 'longer' sequences only if the indices are well-ordered. </td></tr><tr><td comment_id="3813141"> @HemnathPrabagaran: In any case, I did intend my answer to be as useful as possible for readers at all levels, partly because I myself was never taught the motivation for ordinals and had to figure it out myself. Your question prompted me to try to find the most intuitive motivation I could come up with. Anyway you can come back here in the future to read this again, and feel free to ask me questions you have then. =) </td></tr><tr><td comment_id="3813297"> I will. Thanks again! </td></tr><tr><td comment_id="3824564"> Hi again. As I continue exploring the core concept of transfinite ordinals, I'm in need of a clarification: The ordinal ω is the result of solely Von Neumann's ordinal construction, right? In other words, we have the concept of ω today just because Von Neumann created it by his construction of set-theoretic ordinals, correct? (I believe this is the very reason why ω doesn't appear on the number line, as Von Neumann's construction doesn't represent the number line in any way.) </td></tr><tr><td comment_id="3824701"> @HemnathPrabagaran: In modern terms yes <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span> is the von Neumann ordinal. In any case, one can embed <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span> into the affinely extended real line. Just map the finite ordinals to the natural numbers and <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span> to <span class="math-container" id="17231759" visual_id="2076"><math alttext="\infty" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">∞</mi></semantics></math></span>. This correspondence preserves the order, so it's an embedding. </td></tr><tr><td comment_id="3824740"> I see. And another thing that continues evading my understanding is that, what is the difference between ω being defined as an ordinal and ω being defined as an order-type? It's just that, since order types (in layman terms) are simply different ways of arranging an endless number of elements in an infinite set (or am I wrong?), I couldn't understand why or how a transfinite ordinal can also be said to be an order-type, since an ordinal is just a number (or so I believe). I'm just trying to understand the exact nature of transfinite ordinals, that's all. </td></tr><tr><td comment_id="3824752"> @HemnathPrabagaran: Then work through my answer. There is no short-cut. Ordinals are not numbers in any sense of the word. Bringing in order-types muddies things further because they don't exist in ZFC. My answer does not even mention <span class="math-container" id="17231814" visual_id="4986"><math alttext="ω" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi></semantics></math></span>, since it is irrelevant to the general notion of ordinals. Just like you cannot hope to understand how an operating system works if you don't know what is a program, you cannot possibly understand ordinals without knowing induction and recursion and very basic function-related notation. If you have specific questions about any point in my answer, ask those. </td></tr><tr><td comment_id="3824768"> Your response suggests that I'm seeking to understand things that can't really be grasped unless you hold a degree in Maths. Didn't realize that expecting a straightforward explanation in this website would be taken as seeking shortcuts. Anyways, thank you for your time. </td></tr><tr><td comment_id="3824776"> @HemnathPrabagaran: Not quite. Induction/recursion and function-related notation that I used in my answer are present in first-year undergraduate mathematics. Even if set union ("<span class="math-container" id="17231761" visual_id="4006"><math alttext="\bigcup" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo largeop="true" mathsize="160%" stretchy="false" symmetric="true">⋃</mo></semantics></math></span>") is not taught, it is easy enough to grasp. Note that I didn't say that you sought a short-cut, but merely that there is no short-cut. I'm pretty certain that every part of my answer is essential in some way no matter how you construct the ordinals and prove that every well-order is isomorphic to an ordinal. It's just like that. </td></tr><tr><td comment_id="3824807"> @HemnathPrabagaran: Oh and your description of order-types is not right. In my answer, I defined that two total orders to be isomorphic iff there is an order-preserving bijection. In naive set theory we can for each total order construct the set of all total orders isomorphic to it. That can be called the order type. But naive set theory is inconsistent, and ZFC does not allow construction of such an object. So that's why in my answer I directly constructed a von Neumann ordinal isomorphic to the total order, and ZFC allows my construction. </td></tr><tr><td comment_id="3824816"> Your response above, along with simply saying that your earlier answer is the most simplified explanation possible would have sufficed. It seems what I seek to understand cannot be comprehended unless you are atleast actively pursuing a course in Maths. Bluntly telling me to work through your answer earlier, adding there are no shortcuts, simply means that I'm being told not to look for shortcuts. That's ok. Being knowledgeable and being able to impart knowledge to others, irrespective of their level of understanding, are two different things. But thank you for doing your best. </td></tr><tr><td comment_id="3824834"> @HemnathPrabagaran: I decided I had to be direct because you were not (as far as I could tell) actively seeking to understand the underlying mathematics properly, which is not the goal of Math SE. One does not have to actively pursue a course in Math, but has to at least actively seek to understand what is needed. You can either look up the terms I've used without defining or ask in a comment or separate questions. That is better than coming up with 'layman simplifications' that are all wrong. </td></tr><tr><td comment_id="3824837"> @HemnathPrabagaran: On your side remark, it's impossible to teach everyone irrespective of their level of understanding, without first teaching them the prerequisite concepts. It is a widespread fallacy that if you can't explain to a five-year-old then you don't really understand it yourself. It's simply not true. </td></tr><tr><td comment_id="3824897"> The underlying principles you are referring to are part of what I'm trying to understand; they are part of what I sought to be explained when I posted in this page in the first place. I wasn't knowledgeable enough to realize that my questioning bypassed those prerequisites. If this prompted you to blindly assume that I don't actively seek to understand those underlying principles and that I seek shortcuts instead, it was a mistake on your part. And as for my side remark, I wasn't referring to 5-year olds, but rather to people seeking to learn. </td></tr><tr><td comment_id="3825113"> @HemnathPrabagaran: Well in my opinion it was not a mistake on my part, because you didn't ask a single question on the concepts and notation in my answer. This is precisely why I told you to work through my answer. It does not matter how slow, but you have to do it unless you don't wish to have a proper understanding of ordinals. The very fact that you still haven't done so, and have instead tried rephrasing things in 'layman terms', does not help to convince me that you really want to spend the necessary effort to learn. Change my mind! Work through my answer; I'll answer relevant queries. </td></tr><tr><td comment_id="3825284"> You don't have to keep telling me to work through your answer - I'll be doing that anyways over time. And you're not convinced that I'm willing to put in the neccessary effort to learn just because I didn't ask you any question from your first post so far? I clearly indicated in my earlier post I didn't know enough to realize that my questioning bypassed the need to work through your answer firsthand, didn't I? What part of that did you not understand? </td></tr><tr><td comment_id="3825291"> How was I supposed to know that my question (regarding order-types) had anything to do with your first post, since I never asked that question before? This is precisely the reason I didn't sense the need to work through your answer firsthand before posting my question on order-types. And this does not mean I was looking for shortcuts - I just didn't know my question on order-types was related to your first post in any way since this is the very first time I'm asking this question. Hence, you misspoke when you said I was looking for a shortcut. That, my good man, was your mistake. </td></tr><tr><td comment_id="3825303"> @HemnathPrabagaran: I don't understand why you are criticizing me when it is completely your responsibility to **read my answer before making comments**. You have admitted that you didn't sense the need to work through my answer. **That is your mistake.** As I said before, I didn't say you're looking for a shortcut. But certainly your question on order types is answered by my post if you had worked through it! Let's stop this pointless discussion until you actually have questions to ask. I'm not going to answer any more non-technical questions. </td></tr><tr><td comment_id="3825471"> You did indicate that I was looking for shortcuts. Don't bother denying it. That's what really irked me. Even if I made a mistake by not going through your answer first, it still doesn't mean you can outright assume blindly that I'm looking for shortcuts and then post a rash response which was totally unnecessary and out-of-place. Honest questions deserve better. I wasn't quite expecting you to get up jumped about my question, otherwise I'd have never bothered you. But as you said, let's end this now and call it a day. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="1869222"> Difference between set theory proof and logic proof of complete induction </td></tr><tr><td post_id="2271623"> What properties of the positive integers and <span class="math-container" id="20983972" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span> guarantee that repeatedly decreasing by <span class="math-container" id="20983973" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span> eventually leads to <span class="math-container" id="20983974" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span>? </td></tr><tr><td post_id="2202855"> Is there a procedure to transform strong induction proofs into simple induction proofs? </td></tr><tr><td post_id="956779"> An easy to understand definition of <span class="math-container" id="9186737" visual_id="54277"><math alttext="\omega_{1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>1</mn></msub></semantics></math></span>? </td></tr><tr><td post_id="2442635"> How to Think About the Relative Size of Ordinals? </td></tr><tr><td post_id="2480597"> Ordinal numbers, the Burali-Forti paradox, and anti-foundation axioms </td></tr><tr><td post_id="1926967"> Can someone give me an example of a challenging proof by induction? </td></tr><tr><td post_id="2595131"> Axiomatic set theory book recommendation </td></tr><tr><td post_id="1280222"> Ordinals - motivation and rigor at the same time </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
