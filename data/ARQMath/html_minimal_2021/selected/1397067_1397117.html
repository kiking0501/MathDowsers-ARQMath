<!DOCTYPE html>

<html>
<head>
<title>Why do we use "congruent to" instead of equal to?</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Why do we use "congruent to" instead of equal to? </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="1397067">
<p>I'm more familiar with the notation <span class="math-container" id="12975160" visual_id="370138"><math alttext="a\equiv b\pmod{c}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mrow><mi>b</mi><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, but I think this is equivalent to <span class="math-container" id="12975161" visual_id="2305087"><math alttext="a\bmod c=b\bmod c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>a</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>c</mi></mrow><mo>=</mo><mrow><mi>b</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>c</mi></mrow></mrow></semantics></math></span>, which makes it clear that we should put a <span class="math-container" id="12975162" visual_id="3609"><math alttext="=" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo></semantics></math></span> instead of <span class="math-container" id="12975163" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span>.</p> <p>What's the reason for the change of sign? If it's to emphasize that modular equivalence is a congruence relation, why don't we use the <span class="math-container" id="12975164" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span> sign in both notations? </p>
</div>
<hr/>
<div id="tags">
<span> notation </span><span> modular-arithmetic </span><span> congruences </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="2844506"> i guess its so you don'tt have to write <span class="math-container" id="12975165" visual_id="1152683"><math alttext="\mod c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi></mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>c</mi></mrow></semantics></math></span> twice. And an equality sign would not be mathematically correct in that setting </td></tr><tr><td comment_id="2844562"> The spacing is (IMHO) better if you use `\bmod` = binary mod, when you mean the operation that calculates the remainder of a division of one integer by another. </td></tr><tr><td comment_id="2852247"> Somewhat related (relevant to the expression <span class="math-container" id="12975297" visual_id="91324"><math alttext="a\bmod c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>c</mi></mrow></semantics></math></span>): ['mod' or 'remainder' symbol valid in maths?](http://math.stackexchange.com/questions/614931/mod-or-remainder-symbol-valid-in-maths) </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="1397117" id="answer">
<p>I prefer to use the congruence exclusively (I view the remainder operation as a source of headache even though I realize that it is a necessary evil in computing). </p> <p>But I use both <em>equal</em> (<span class="math-container" id="12975182" visual_id="3609"><math alttext="=" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo></semantics></math></span>) and <em>congruent to</em> (<span class="math-container" id="12975183" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span>) signs together when processing a lengthy calculation in modular arithmetic. My freshman algebra students quickly catch on with my calculations like <span class="math-container" id="12975184" visual_id="9063815"><math alttext="12^{3004}\equiv 5^{3004}=5^{3000}\cdot 5^{4}=(5^{6})^{500}\cdot 5^{4}\equiv 1^% {500}\cdot 5^{4}=25^{2}\equiv 4^{2}=16\equiv 2\pmod{7}." class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mn>12</mn><mn>3004</mn></msup><mo>≡</mo><msup><mn>5</mn><mn>3004</mn></msup><mo>=</mo><mrow><msup><mn>5</mn><mn>3000</mn></msup><mo>⋅</mo><msup><mn>5</mn><mn>4</mn></msup></mrow><mo>=</mo><mrow><msup><mrow><mo stretchy="false">(</mo><msup><mn>5</mn><mn>6</mn></msup><mo stretchy="false">)</mo></mrow><mn>500</mn></msup><mo>⋅</mo><msup><mn>5</mn><mn>4</mn></msup></mrow><mo>≡</mo><mrow><msup><mn>1</mn><mn>500</mn></msup><mo>⋅</mo><msup><mn>5</mn><mn>4</mn></msup></mrow><mo>=</mo><msup><mn>25</mn><mn>2</mn></msup><mo>≡</mo><msup><mn>4</mn><mn>2</mn></msup><mo>=</mo><mn>16</mn><mo>≡</mo><mrow><mn>2</mn><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mn>7</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>.</mo></mrow></semantics></math></span> IOW, I use <span class="math-container" id="12975185" visual_id="3609"><math alttext="=" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo></semantics></math></span> when there is an equality of integers between the steps, and <span class="math-container" id="12975186" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span> when I mean a congruence. The power of laws obeyed by congruences is apparent. Checking/following the progress of the calculation is easier this way. Of course, using <span class="math-container" id="12975187" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span> all the way is correct also. The <span class="math-container" id="12975188" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span> is there as a reminder that in this step we do something that only results in a congruence.</p> <p>As the students become acquainted with the language of residue class rings, I gradually stop making the distinction between <span class="math-container" id="12975189" visual_id="3609"><math alttext="=" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo></semantics></math></span> and <span class="math-container" id="12975190" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span> as well as, clarity of context permitting, the distinction between <span class="math-container" id="12975191" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> and <span class="math-container" id="12975192" visual_id="110603"><math alttext="\overline{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover accent="true"><mi>n</mi><mo>¯</mo></mover></semantics></math></span>. </p> <p>Thinking about what that would look like when done by somebody who is only familiar with binary mod makes me shudder.</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="2844611"> Sorry about the rantish parts. It is rare that I manage to pass up an opportunity to criticize the use of binary mod. IMHO it is a cancer of elementary number theory at worst, and, at best, an attempt to hide (from the innocent students) the fact that calculations now take place in a ring of residue classes as opposed to in the ring of integers. </td></tr><tr><td comment_id="2844658"> So some people are now using binary mod in _number theory?_ If so, I support your rant. I use binary mod frequently _in software,_ where the benefits seem worth the headaches, sometimes because it's not always convenient to store the result of a calculation as a residue class rather than as a number, sometimes as a convenient way to decide which arc between two points on a circle is shorter. And therefore I'm familiar with things that make the operator a liability in number theory, such as the fact that people disagree on how to deal with negative operands. </td></tr><tr><td comment_id="2844672"> @DavidK: I doubt anybody is using binary mod in number theory. I have just seen many confused computer science majors taking a course in cryptography at our department, and smirking software engineers lecturing me how I need to insert umpteen mod's at selected places in some formula for it to work *as a Matlab snippet*. I do realize the need for this in software. I have created bugs when I didn't know that for a processor the range of binary mod may vary according to the sign :-) Thankfully such a program will act up sooner rather than later, so debugging is easy (except on the first time). </td></tr><tr><td comment_id="2844737"> In software, a chain of eight equivalence relations (as shown in this answer) has to be expressed as a conjunction of eight Boolean expressions such as <span class="math-container" id="12975193" visual_id="9063816"><math alttext="1^{500}\cdot 5^{4}=25^{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mn>1</mn><mn>500</mn></msup><mo>⋅</mo><msup><mn>5</mn><mn>4</mn></msup></mrow><mo>=</mo><msup><mn>25</mn><mn>2</mn></msup></mrow></semantics></math></span>. That's the main complication. In my opinion, the correct way to express the <span class="math-container" id="12975340" visual_id="29462"><math alttext="\equiv" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≡</mo></semantics></math></span> relation in software is as a function of three parameters returning true if the first two parameters are equivalent modulo the third; the actual operation to use is one division with remainder (<span class="math-container" id="12975195" visual_id="575233"><math alttext="(a-b)\bmod c=0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>-</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>c</mi></mrow><mo>=</mo><mn>0</mn></mrow></semantics></math></span>) rather than two. I suspect your smirking software engineers have been using twice as many mods as needed. </td></tr><tr><td comment_id="2846780"> Use `%` for binary mod! It is such a clean and neat operator and directly applicable to real numbers without even changing its definition <span class="math-container" id="12975196" visual_id="4557874"><math alttext="x\%y=x-\lfloor\frac{x}{y}\rfloor y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mi>x</mi><mo>%</mo></mrow><mo>⁢</mo><mi>y</mi></mrow><mo>=</mo><mrow><mi>x</mi><mo>-</mo><mrow><mrow><mo stretchy="false">⌊</mo><mfrac><mi>x</mi><mi>y</mi></mfrac><mo stretchy="false">⌋</mo></mrow><mo>⁢</mo><mi>y</mi></mrow></mrow></mrow></semantics></math></span>. You can then write things like <span class="math-container" id="12975197" visual_id="9063817"><math alttext="(a^{k})\%b=((a\%b)^{k})\%b" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><mo>%</mo></mrow><mo>⁢</mo><mi>b</mi></mrow><mo>=</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><msup><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>a</mi><mo>%</mo></mrow><mo>⁢</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><mo>%</mo></mrow><mo>⁢</mo><mi>b</mi></mrow></mrow></semantics></math></span> for any positive reals <span class="math-container" id="12975198" visual_id="249"><math alttext="a,b" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow></semantics></math></span> and integer <span class="math-container" id="12975213" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span>. Nice? =D </td></tr><tr><td comment_id="2847529"> Hmm, a few hours ago I had the occasion to remind someone that exponentiation is not a binary operation modulo <span class="math-container" id="12975200" visual_id="625"><math alttext="q" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi></semantics></math></span>, "because <span class="math-container" id="12975201" visual_id="9063818"><math alttext="a^{b}\bmod q\neq a^{b\bmod q}\bmod q" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>a</mi><mi>b</mi></msup><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>q</mi></mrow><mo>≠</mo><mrow><msup><mi>a</mi><mrow><mi>b</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>q</mi></mrow></msup><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>q</mi></mrow></mrow></semantics></math></span> in general". I don't think it would have made that point as well for the target audience if I had had to express it as "because <span class="math-container" id="12975202" visual_id="9063819"><math alttext="b\equiv c\pmod{q}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≡</mo><mrow><mi>c</mi><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> does not imply <span class="math-container" id="12975203" visual_id="9063820"><math alttext="a^{b}\equiv a^{c}\pmod{q}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>b</mi></msup><mo>≡</mo><mrow><msup><mi>a</mi><mi>c</mi></msup><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>q</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>". </td></tr><tr><td comment_id="2847535"> @user21820: I agree that C-styl<span class="math-container" id="26317251">i</span>sh use of `%` is a good idea. The power of congruence is that you really ever need a single `mod` per calculation. Actually you can just state that all the arithmetic is done modulo <span class="math-container" id="12975358" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> and be done with writing `mod` at all! Binary mod will be strictly needed, if there are several different moduli in the same calculation. But that is so unnatural. Mind you, I had to do just that for one of my contributions (a pilot signal offset scheme) to a 4G standardization body. It was later decided not to use such schemes at all (to my relief :-) </td></tr><tr><td comment_id="2847538"> LOL, @Henning! I have faced the same problem as a teacher. That is a good opportunity to explain that in the language of rings the exponents of power still are natural numbers even though the elements of the ring may be residue classes. </td></tr><tr><td comment_id="2847550"> @user21820: The trouble with using `%` for binary mod is that this symbol already has a _different but strongly confuseable_ meaning in many programming languages. In Java, C#, C, and C++  `(-9)%7` evaluates to <span class="math-container" id="12975205" visual_id="2116"><math alttext="-2" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>-</mo><mn>2</mn></mrow></semantics></math></span>, whereas in order to be sanely useful for modular arithmetic we _must_ have <span class="math-container" id="12975206" visual_id="9063821"><math alttext="(-9)\bmod 7=5" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mo>-</mo><mn>9</mn></mrow><mo stretchy="false">)</mo></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mn>7</mn></mrow><mo>=</mo><mn>5</mn></mrow></semantics></math></span>. </td></tr><tr><td comment_id="2847976"> Just to muddy the waters, in crypto at least there are some situations where one legitimately needs to mix modular arithmetic under different moduli. For example, [ElGamal signature generation](https://en.wikipedia.org/wiki/ElGamal_signature_scheme) basically involves first computing <span class="math-container" id="12975207" visual_id="9063822"><math alttext="r=(g^{k}\bmod p)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>g</mi><mi>k</mi></msup><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>p</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> and then <span class="math-container" id="12975208" visual_id="9063823"><math alttext="s\equiv(H-rx)k^{-1}\pmod{p-1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>≡</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>H</mi><mo>-</mo><mrow><mi>r</mi><mo>⁢</mo><mi>x</mi></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><msup><mi>k</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mrow><mi>p</mi><mo>-</mo><mn>1</mn></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. Yes, I'm mixing both notations here on purpose: in the first formula, <span class="math-container" id="12975209" visual_id="180"><math alttext="r" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi></semantics></math></span> really needs to be chosen as the least non-negative representative of its congruence class modulo <span class="math-container" id="12975210" visual_id="74"><math alttext="p" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi></semantics></math></span>, while the second formula involves a modular inverse modulo <span class="math-container" id="12975214" visual_id="1327"><math alttext="p-1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>-</mo><mn>1</mn></mrow></semantics></math></span>. </td></tr><tr><td comment_id="2847984"> ...see e.g. [this answer I wrote on crypto.SE](http://crypto.stackexchange.com/questions/1479/elgamal-signature-scheme-recovering-the-key-when-reusing-randomness/1520#1520) for more details. Anyway, I'm not sure if that's really an argument for or against "binary mod" -- I just wanted to toss it out here for some extra confusion. ;-) </td></tr><tr><td comment_id="2848315"> @HenningMakholm: Yes I know the programming `%` is different from my definition but there is no choice if we want one consistent with mathematical use so I ignored the programming version. =D </td></tr><tr><td comment_id="2848318"> @IlmariKaronen: We could of course define <span class="math-container" id="12975212" visual_id="9063824"><math alttext="k^{-1}_{p-1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>k</mi><mrow><mi>p</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msubsup></semantics></math></span> to mean the inverse of <span class="math-container" id="12975213" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span> mod <span class="math-container" id="12975214" visual_id="1327"><math alttext="p-1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>-</mo><mn>1</mn></mrow></semantics></math></span>. =D </td></tr><tr><td comment_id="2848348"> @JyrkiLahtonen: I’m inclined to say that you’re lucky to have such clever students that they “quickly catch on” to things like <span class="math-container" id="12975215" visual_id="9063825"><math alttext="A\equiv B=C=D\equiv E\pmod{b}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi><mo>=</mo><mi>C</mi><mo>=</mo><mi>D</mi><mo>≡</mo><mrow><mi>E</mi><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>.  Modular congruence seems to be a difficult concept for people to grasp — unless they’re well versed in the topic of equivalence relationships, and how widely (and how well) is that taught?  It’s a pet peeve of mine that some computer language designer provided the remainder function and called it `MOD` — I wonder whether that can be traced to the BASIC programming language  … (Cont’d) </td></tr><tr><td comment_id="2848351"> (Cont’d) …  and its unfortunate choice of `REM` (short for `REMARK`) as the token to begin a comment — and, as a result, millions of people believe (incorrectly) that they know what “modulo” means.  (These people will often argue that a statement like <span class="math-container" id="12975216" visual_id="9063826"><math alttext="4\equiv 7\pmod{3}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>≡</mo><mrow><mn>7</mn><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mn>3</mn></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> is false or even nonsense.)  I’m glad I’m not alone in my feelings. </td></tr><tr><td comment_id="2849194"> @user21820 If you borrow something from programming languages, it comes with some unwanted baggage, like it or not. I've been programming computers for a few decades now; I'm well familiar with `%`. It is an extremely useful operator when used well; I've also seen people get themselves into all kinds of difficulty by misusing it. </td></tr><tr><td comment_id="2849213"> @DavidK: If one clearly defines all notation used, there is no problem. If one does not, then every notation is subject to the same criticism. For example does <span class="math-container" id="12975217" visual_id="28679"><math alttext="\subset" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊂</mo></semantics></math></span> mean proper subset or not? And does <span class="math-container" id="12975218" visual_id="39023"><math alttext="\supset" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊃</mo></semantics></math></span> mean superset or material implication (which would be represented in set theory by <span class="math-container" id="12975219" visual_id="2198"><math alttext="\subseteq" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊆</mo></semantics></math></span>...) What about <span class="math-container" id="12975220" visual_id="26481"><math alttext="\mid" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∣</mo></semantics></math></span>? Does it mean bitwise-or? So you cannot criticise the use of `%` if you ever use `|` in mathematical expressions. </td></tr><tr><td comment_id="2852292"> @user21820 I'm not saying you can't use `%`; I'm just saying it comes with baggage. In fact <span class="math-container" id="12975221" visual_id="116650"><math alttext="a\bmod b" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>b</mi></mrow></semantics></math></span> has much the same baggage. The problem is not that one symbol has two meanings: for example, vertical bar can mean many different things in math, none of which will be confused with bitwise or. The problem is when you're using a symbol _almost_ but _not quite_ the way it is defined elsewhere. Then you should take extra care to ensure that people do not read the symbol the wrong way. </td></tr><tr><td comment_id="2852922"> @DavidK: Ah I get what you mean. Certainly. Personally I always define everything precisely before using it, and give good test cases to show what it means (so for binary mod test cases would include negative numbers). So we're fully in agreement then. =) </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="1580040"> Why is <span class="math-container" id="14594778" visual_id="5273368"><math alttext="-145\mod 63=44" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mo>-</mo><mn>145</mn></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mn>63</mn></mrow><mo>=</mo><mn>44</mn></mrow></semantics></math></span>? </td></tr><tr><td post_id="1398245"> Generalized modulo arithmetic </td></tr><tr><td post_id="1812634"> Need a proof for a modular arithmetic property </td></tr><tr><td post_id="614931"> Name of 'mod' or 'remainder' operation in mathematics </td></tr><tr><td post_id="578749"> Proving for every odd number <span class="math-container" id="5942055" visual_id="67"><math alttext="x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi></semantics></math></span>, <span class="math-container" id="5942056" visual_id="513"><math alttext="x^{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mn>2</mn></msup></semantics></math></span> is always congruent to <span class="math-container" id="5942057" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span> or <span class="math-container" id="5942058" visual_id="3052"><math alttext="9" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>9</mn></semantics></math></span> modulo <span class="math-container" id="5942059" visual_id="4522"><math alttext="24" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>24</mn></semantics></math></span> </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
