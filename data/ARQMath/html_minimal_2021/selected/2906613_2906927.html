<!DOCTYPE html>

<html>
<head>
<title>A curious variant of the classical 2D random walk: allowing duplication and vanishing</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> A curious variant of the classical 2D random walk: allowing duplication and vanishing </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="2906613">
<p><strong>Background.</strong> Recall the standard random walk on a 2D grid (i.e. <span class="math-container" id="26897259" visual_id="3377"><math alttext="\mathbb{Z}^{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℤ</mi><mn>2</mn></msup></semantics></math></span>). A person starts at the origin. At every iteration, the person moves in one of the four directions (up, down, left, or right), each with a probability <span class="math-container" id="26897260" visual_id="3501"><math alttext="1/4" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>/</mo><mn>4</mn></mrow></semantics></math></span>. It is well-known that the person will at some point return to the origin with probability <span class="math-container" id="26897261" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span>.</p> <p>We now consider the following variant.  A person starts at the origin. At the first iteration, for each of the four points surrounding the person, a 'duplicate' of the original person is placed at this point with probability <span class="math-container" id="26897262" visual_id="3501"><math alttext="1/4" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>/</mo><mn>4</mn></mrow></semantics></math></span>; we remove the person at the origin. We do <em>not</em> require that there be exactly one duplicate. It can happen that there are more than one, or even that there are none altogether (in which case the simulation halts). At the following iterations, we repeat the process for each of the duplicates that we have: at each of the four points surrounding a given duplicate, a new duplicate is placed with probability <span class="math-container" id="26897263" visual_id="3501"><math alttext="1/4" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>/</mo><mn>4</mn></mrow></semantics></math></span>, and the original duplicate is removed.</p> <p><strong>Example.</strong> A process could go as follows: <span class="math-container" id="26897264" visual_id="4125209"><math alttext="\{(0,0)\}\Rightarrow\{(0,1)\}\Rightarrow\{(0,0),(0,2)\}\Rightarrow\{(0,1),(0,1% )\}\Rightarrow\{(1,1)\}\Rightarrow\{\}." class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">}</mo></mrow><mo>⇒</mo><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">}</mo></mrow><mo>⇒</mo><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mo>,</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">}</mo></mrow><mo>⇒</mo><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo>,</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">}</mo></mrow><mo>⇒</mo><mrow><mo stretchy="false">{</mo><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">}</mo></mrow><mo>⇒</mo><mrow><mo stretchy="false">{</mo><mo stretchy="false">}</mo></mrow></mrow><mo>.</mo></mrow></semantics></math></span> Notice that it can happen that more than one duplicate is at the same spot, and that the process halts after the duplicate on <span class="math-container" id="26897265" visual_id="935"><math alttext="(1,1)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> no longer formed any new duplicates.</p> <blockquote> <p><strong>Question.</strong> We simulate the random walk described above. Throughout the simulation, we count the number of times that a duplicate is formed at the origin. What is the probability that at least one duplicate will return to the origin?</p> <p><strong>Follow-up question.</strong> What is the probability distribution for the number of returns to the origin, and can we derive from this the expected number of returns?</p> </blockquote> <p><strong>What I know.</strong> </p> <ul> <li><p>I am vaguely aware that the simulation will halt (because there are no more duplicates) in a finite amount of time with probability <span class="math-container" id="26897266" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span>. (This is probably a well-known result for the set people working within this area, but I am not an element thereof.) So we need not worry about the number of returns being infinite.</p></li> <li><p>The probability that the simulation halts at the first iteration is <span class="math-container" id="26897267" visual_id="4125210"><math alttext="(3/4)^{4}\approx 0.32" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="false">(</mo><mrow><mn>3</mn><mo>/</mo><mn>4</mn></mrow><mo stretchy="false">)</mo></mrow><mn>4</mn></msup><mo>≈</mo><mn>0.32</mn></mrow></semantics></math></span>, thus giving a trivial (and weak) upper bound for the probability of returning at least once, at about <span class="math-container" id="26897268" visual_id="856254"><math alttext="0.68" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.68</mn></semantics></math></span>.</p></li> <li><p>I have run the simulation 1.000.000 times in Python. The numerical results are as follows. It states the number of simulations that yielded a given number of returns to the origin. \begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|} \hline \text{Returns} &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp; &gt;10 \\ \hline \text{Runs} &amp; 682919 &amp; 143705 &amp; 56318 &amp; 29616 &amp; 17856 &amp; 11876 &amp; 8512 &amp; 6342 &amp; 4898 &amp; 3964 &amp; 3312 &amp; 30682 \\ \hline \end{array} Here's a plot of the first 80 values. The <span class="math-container" id="26897269" visual_id="67"><math alttext="x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi></semantics></math></span>-axis represents the number of returns; the <span class="math-container" id="26897270" visual_id="68"><math alttext="y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi></semantics></math></span>-value represents the number of runs with <span class="math-container" id="26897271" visual_id="67"><math alttext="x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi></semantics></math></span> returns. The values at <span class="math-container" id="26897272" visual_id="15181"><math alttext="x=0,1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></mrow></semantics></math></span> have been cut off from the image so as to make the rest visible. <a href="https://i.stack.imgur.com/MyuFG.png" rel="nofollow noreferrer"><img alt="enter image description here" src="https://i.stack.imgur.com/MyuFG.png"/></a> We find that the probability of returning at least once is approximately <span class="math-container" id="26897273" visual_id="4125211"><math alttext="0.317" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.317</mn></semantics></math></span>. </p></li> <li>Remarkably, there are also a bunch of extreme outliers. When I ran 100.000 runs without artificial termination, about one in a hundred simulations yielded more than a hundred returns. Two runs even yielded thousands of returns. (One yielded <span class="math-container" id="26897274" visual_id="4125212"><math alttext="8205" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>8205</mn></semantics></math></span> returns. It lasted for <span class="math-container" id="26897275" visual_id="4125213"><math alttext="23230" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>23230</mn></semantics></math></span> iterations, and at its peak there were <span class="math-container" id="26897276" visual_id="4125214"><math alttext="13769" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>13769</mn></semantics></math></span> duplicates on the grid. The other gave even more: <span class="math-container" id="26897277" visual_id="4125215"><math alttext="13823" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>13823</mn></semantics></math></span> returns after <span class="math-container" id="26897278" visual_id="4125216"><math alttext="70578" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>70578</mn></semantics></math></span> iterations, with a peak number of <span class="math-container" id="26897279" visual_id="4125217"><math alttext="44232" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>44232</mn></semantics></math></span> duplicates.) These outliers strongly influence the expected value. Estimates of the expected value are inconsistent. Though in the comments, user joriki gives a compelling argument in the comments that we should expect the value to be infinite.</li> </ul>
</div>
<hr/>
<div id="tags">
<span> probability </span><span> probability-theory </span><span> stochastic-processes </span><span> recreational-mathematics </span><span> random-walk </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="6003981"> Nice question! I think the expected number of returns to the origin is infinite. The recurrence for this is that the expected number of visits to the origin from a given point is the average of the one from the four neighbours. This is the same recurrence as for the standard random walk. The only bounded solution to this recurrence is a constant one, and a spatially constant finite expectation seems implausible. </td></tr><tr><td comment_id="6003998"> Interesting! My thoughts were the opposite. Here's my intuition. If, at the start of an iteration, we have <span class="math-container" id="26897313" visual_id="302"><math alttext="d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi></semantics></math></span> duplicates, then the expected number of duplicates *after* the iteration is precisely <span class="math-container" id="26897313" visual_id="302"><math alttext="d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi></semantics></math></span> again (with the variance depending on <span class="math-container" id="26897313" visual_id="302"><math alttext="d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi></semantics></math></span>). The variable <span class="math-container" id="26897313" visual_id="302"><math alttext="d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi></semantics></math></span> reminds me of a <span class="math-container" id="26897288" visual_id="66516"><math alttext="1D" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⁢</mo><mi>D</mi></mrow></semantics></math></span> random walk on its own. Since the *expected* amount of time to get from <span class="math-container" id="26897305" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span> (because we begin with <span class="math-container" id="26897286" visual_id="14898"><math alttext="d=1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mn>1</mn></mrow></semantics></math></span> person) to <span class="math-container" id="26897299" visual_id="92"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span> is finite for a standard <span class="math-container" id="26897288" visual_id="66516"><math alttext="1D" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⁢</mo><mi>D</mi></mrow></semantics></math></span> random walk, I conclude that the expected length of my simulation is also finite, which I presume implies a finite number of expected returns, too. </td></tr><tr><td comment_id="6004010"> I don't think it does. I agree that the expected length of the simulation is probably finite, but that doesn't imply that the number of expected returns is finite. The number of returns in the longer runs might grow more than linearly with the length of the runs. It would be interesting to know the length of the run that yielded <span class="math-container" id="26897289" visual_id="4125218"><math alttext="10480" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>10480</mn></semantics></math></span> returns to the origin. </td></tr><tr><td comment_id="6004015"> Thanks! That makes sense. The program did not spit out any data other than the number of returns. All I know is it was a massive run as my computer choked on it quite for a while. </td></tr><tr><td comment_id="6004104"> @joriki The program no longer forgets the length. I just encountered a run that yielded <span class="math-container" id="26897290" visual_id="4125212"><math alttext="8205" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>8205</mn></semantics></math></span> returns. Its length was <span class="math-container" id="26897291" visual_id="4125213"><math alttext="23230" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>23230</mn></semantics></math></span> iterations. At its peak there were a total of <span class="math-container" id="26897292" visual_id="4125214"><math alttext="13769" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>13769</mn></semantics></math></span> duplicates on the grid. </td></tr><tr><td comment_id="6004555"> About the extinction probability: If we consider only the number of duplicates and forget about their positions, this is a [branching process](https://en.wikipedia.org/wiki/Branching_process#Extinction_problem), and the extinction probability of a branching process is known to be <span class="math-container" id="26897305" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span> if, as in this case, the average number of descendants per individual is less than or equal to <span class="math-container" id="26897305" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span>. </td></tr><tr><td comment_id="6007024"> Actually, I don't think the expected length of the simulation is finite, either. It's not true that, as you wrote above, the expected time to reach <span class="math-container" id="26897299" visual_id="92"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span> from <span class="math-container" id="26897305" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span> is finite for a standard one-dimensional random walk. The walk reaches <span class="math-container" id="26897299" visual_id="92"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span> with probability <span class="math-container" id="26897305" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span>, but that doesn't imply that the expected time to reach <span class="math-container" id="26897299" visual_id="92"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span> is finite. It satisfies the recurrence <span class="math-container" id="26897300" visual_id="986690"><math alttext="a_{k}=1+\frac{1}{2}(a_{k-1}+a_{k+1})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub><mo>=</mo><mrow><mn>1</mn><mo>+</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></semantics></math></span>. The solution is quadratic and thus unbounded, so the recurrence can't be satisfied by finite hitting times, so the hitting times are infinite. </td></tr><tr><td comment_id="6012472"> @joriki Wow, that's crazy. I guess I just blindly assumed the expected return time in 1D walks to be finite. </td></tr><tr><td comment_id="6012485"> Check out [the generating function of the Catalan numbers](https://en.wikipedia.org/wiki/Catalan_number#First_proof). If you substitute <span class="math-container" id="26897301" visual_id="2750204"><math alttext="x=\frac{1}{4}y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mrow><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>⁢</mo><mi>y</mi></mrow></mrow></semantics></math></span> (where the factor <span class="math-container" id="26897302" visual_id="1118"><math alttext="\frac{1}{4}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mn>4</mn></mfrac></semantics></math></span> represents the probability for two steps in the random walk), you get (up to a factor of <span class="math-container" id="26897303" visual_id="358"><math alttext="2" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn></semantics></math></span>) the probability generating function for first returns to the origin in a symmetric random walk. Then substituting <span class="math-container" id="26897307" visual_id="1972"><math alttext="y=1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow></semantics></math></span> yields the probability of return (in this case <span class="math-container" id="26897305" visual_id="342"><math alttext="1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn></semantics></math></span>), and differentiating and then substituting <span class="math-container" id="26897307" visual_id="1972"><math alttext="y=1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow></semantics></math></span> yields the expected return time (in this case infinite because of the singularity at <span class="math-container" id="26897307" visual_id="1972"><math alttext="y=1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow></semantics></math></span>). </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="2906927" id="answer">
<p>I doubt that you'll find a closed form for the probability of at least one return to the origin, but we can compute it to high accuracy using the recurrence</p> <p><span class="math-container" id="26897308" visual_id="4125219"><math alttext="p_{x}=1-\prod_{n\in N(x)}\left(1-\frac{p_{n}}{4}\right)\;," class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mi>p</mi><mi>x</mi></msub><mo>=</mo><mrow><mn>1</mn><mo>-</mo><mrow><msub><mo largeop="true" symmetric="true">∏</mo><mrow><mi>n</mi><mo>∈</mo><mrow><mi>N</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></msub><mrow><mo>(</mo><mrow><mn>1</mn><mo>-</mo><mfrac><msub><mi>p</mi><mi>n</mi></msub><mn>4</mn></mfrac></mrow><mo rspace="5.3pt">)</mo></mrow></mrow></mrow></mrow><mo>,</mo></mrow></semantics></math></span></p> <p>where <span class="math-container" id="26897309" visual_id="37819"><math alttext="p_{x}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>x</mi></msub></semantics></math></span> is the probability that a duplicate at <span class="math-container" id="26897310" visual_id="67"><math alttext="x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi></semantics></math></span> results in at least one duplicate at the origin and the product is over the four neighbours <span class="math-container" id="26897311" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span> of <span class="math-container" id="26897312" visual_id="67"><math alttext="x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi></semantics></math></span>.</p> <p><a href="https://gist.github.com/joriki/83f6dd92d5e4b70a01975f7948e9766f" rel="nofollow noreferrer">This Java code</a> numerically solves this recurrence on square grids of increasing linear dimension <span class="math-container" id="26897313" visual_id="302"><math alttext="d" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi></semantics></math></span>, with zero boundary conditions outside the grid considered, with the condition <span class="math-container" id="26897314" visual_id="4125220"><math alttext="p_{O}=1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>O</mi></msub><mo>=</mo><mn>1</mn></mrow></semantics></math></span> at the origin. The resulting approximate return probabilities <span class="math-container" id="26897315" visual_id="874357"><math alttext="q_{d}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mi>d</mi></msub></semantics></math></span> are</p> <p>\begin{array}{r|l} d&amp;q_d\\\hline 2&amp;0.2709071974706553\\ 4&amp;0.31195166907949623\\ 8&amp;0.317093534115794\\ 16&amp;0.3175509956401311\\ 32&amp;0.3175807088889516\\ 64&amp;0.3175822392633748\\ 128&amp;0.31758230687588884\\ 256&amp;0.3175823095925555\\ 512&amp;0.3175823096957242\\ 1024&amp;0.31758230969951595 \end{array}</p> <p>So the probability of at least one return is about <span class="math-container" id="26897316" visual_id="4125221"><math alttext="0.3175823097" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.3175823097</mn></semantics></math></span>, in agreement with your simulations.</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="6012484"> That's pretty neat, and it seems nicely adaptable if one were to try and generalize to higher dimensions (though I presume you'll just end up with smaller arbitrary numbers). Thanks for your help. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
