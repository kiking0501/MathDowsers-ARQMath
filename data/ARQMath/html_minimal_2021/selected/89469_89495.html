<!DOCTYPE html>

<html>
<head>
<title>Question about the Dual Statement for Injective Modules</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Question about the Dual Statement for Injective Modules </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="89469">
<p>It's well-known that there are several equivalent definitions of a projective <span class="math-container" id="1018623" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>-module <span class="math-container" id="1018624" visual_id="318"><math alttext="P" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi></semantics></math></span>:</p> <ol> <li>Given an exact sequence <span class="math-container" id="1018625" visual_id="428123"><math alttext="M\xrightarrow{f}M^{\prime}\to 0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mover accent="true"><mo>‚Üí</mo><mo>ùëì</mo></mover><msup><mi>M</mi><mo>‚Ä≤</mo></msup><mo>‚Üí</mo><mn>0</mn></mrow></semantics></math></span> and a morphism <span class="math-container" id="1018626" visual_id="428124"><math alttext="P\xrightarrow{g}M^{\prime}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mover accent="true"><mo>‚Üí</mo><mo>ùëî</mo></mover><msup><mi>M</mi><mo>‚Ä≤</mo></msup></mrow></semantics></math></span>, there exists a morphism <span class="math-container" id="1018627" visual_id="428125"><math alttext="P\xrightarrow{h}M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mover accent="true"><mo>‚Üí</mo><mo>‚Ñé</mo></mover><mi>M</mi></mrow></semantics></math></span> such that <span class="math-container" id="1018628" visual_id="428126"><math alttext="fh=g" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>‚Å¢</mo><mi>h</mi></mrow><mo>=</mo><mi>g</mi></mrow></semantics></math></span>; </li> <li>Every exact sequence <span class="math-container" id="1018629" visual_id="428127"><math alttext="0\to M^{\prime}\to M\to P\to 0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>‚Üí</mo><msup><mi>M</mi><mo>‚Ä≤</mo></msup><mo>‚Üí</mo><mi>M</mi><mo>‚Üí</mo><mi>P</mi><mo>‚Üí</mo><mn>0</mn></mrow></semantics></math></span> splits; </li> <li>There exists a module <span class="math-container" id="1018630" visual_id="4"><math alttext="M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi></semantics></math></span> such that <span class="math-container" id="1018631" visual_id="428128"><math alttext="P\oplus M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>‚äï</mo><mi>M</mi></mrow></semantics></math></span> is a free module; and </li> <li>The functor <span class="math-container" id="1018632" visual_id="428129"><math alttext="\mathrm{Hom}_{A}(P,-)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Hom</mi><mi>A</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>P</mi><mo>,</mo><mo>-</mo><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> is exact.  </li> </ol> <p>Now the dual versions (i.e., for the definition of an injective module) of 1, 2, and 4 are easy.  My question is, does there exist a dual version of 3?  </p> <p>I would actually like to be phrasing this in the context of an arbitrary abelian category, so would 3 be stated as something like "a subobject of a free object"?  Then what would the dual version of this statement be?  "A quotient object of..." something?</p> <p>Thanks so much in advance.  </p>
</div>
<hr/>
<div id="tags">
<span> abstract-algebra </span><span> category-theory </span><span> modules </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="210637"> "Quotient of a cofree object"... You need to think a bit what "free object" really means, so as to see if you can dualize it. </td></tr><tr><td comment_id="210656"> @Mariano: Well, except that "direct summand" is more than just "submodule"... </td></tr><tr><td comment_id="210661"> Yeah, indeed (I was dualizing the statement in the 3rd oparagraph, really) The problem is more with the ¬´cofree object¬ª part, though, no? </td></tr><tr><td comment_id="210669"> @Mariano: Could be. Then again, if "free object" means "direct sum of copies of <span class="math-container" id="1018677" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>", then it's not that hard... </td></tr><tr><td comment_id="210672"> Well, free means more ¬´in the image of the adjoint to the forgetful functor to sets¬ª... </td></tr><tr><td comment_id="210689"> @dmdmdmdmdmd: Perhaps [this MO question](http://mathoverflow.net/questions/39490/dualizing-the-definition-of-a-free-group/39501#39501) (and the comments) might be helpful in that direction. </td></tr><tr><td comment_id="210690"> @dmdmdmdmdmd: Also: keep in mind that the duality between projectives and injectives is *not* perfect; for example, every module has an injective hull, but there is no dual "projective" notion that exists for all modules. In other words: it may not be possible to dualize the condition. </td></tr><tr><td comment_id="210901"> In the category of finitely generated modules for a finite dimensional algebra <span class="math-container" id="1018634" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span> over a field <span class="math-container" id="1018635" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span>, you can replace 3) by "there exists <span class="math-container" id="1018636" visual_id="4"><math alttext="M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi></semantics></math></span> such that <span class="math-container" id="1018637" visual_id="428130"><math alttext="I\oplus M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>‚äï</mo><mi>M</mi></mrow></semantics></math></span> is a direct sum of copies of <span class="math-container" id="1018638" visual_id="428131"><math alttext="(A_{A})^{*}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="false">(</mo><msub><mi>A</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><mo>*</mo></msup></semantics></math></span>".  (<span class="math-container" id="1018639" visual_id="989"><math alttext="I" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi></semantics></math></span> is a left <span class="math-container" id="1018640" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>-module and * is <span class="math-container" id="1018641" visual_id="428132"><math alttext="\hom_{k}(-,k)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>hom</mi><mi>k</mi></msub><mo>‚Å°</mo><mrow><mo stretchy="false">(</mo><mo>-</mo><mo>,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>) </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="89495" id="answer">
<p>Let's follow up on the comments.</p> <p>A first attempt at dualizing the condition would dualize "direct summand" (it's actually self-dual, since a direct summand is either an onto homomorphism <span class="math-container" id="1018642" visual_id="428133"><math alttext="F\to P" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>‚Üí</mo><mi>P</mi></mrow></semantics></math></span> that has a section, or a one-to-one homomorphism <span class="math-container" id="1018643" visual_id="428134"><math alttext="P\to F" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>‚Üí</mo><mi>F</mi></mrow></semantics></math></span> that has a retraction) and "free module". </p> <p>The "free module on <span class="math-container" id="1018644" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>" is <span class="math-container" id="1018645" visual_id="428135"><math alttext="\mathbf{F}(X)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÖ</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, where <span class="math-container" id="1018646" visual_id="428136"><math alttext="\mathbf{F}\colon\mathscr{Set}\to R\mathscr{mod}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÖ</mi><mo>:</mo><mrow><mrow><mi class="ltx_font_mathscript">ùíÆ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">‚ÑØ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùìâ</mi></mrow><mo>‚Üí</mo><mrow><mi>R</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùìÇ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">‚Ñ¥</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùíπ</mi></mrow></mrow></mrow></semantics></math></span> is the left adjoint of the underlying set function <span class="math-container" id="1018647" visual_id="428137"><math alttext="\mathbf{U}\colon R\mathscr{mod}\to\mathscr{Set}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêî</mi><mo>:</mo><mrow><mrow><mi>R</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùìÇ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">‚Ñ¥</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùíπ</mi></mrow><mo>‚Üí</mo><mrow><mi class="ltx_font_mathscript">ùíÆ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">‚ÑØ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùìâ</mi></mrow></mrow></mrow></semantics></math></span>.  So a "co-free module on <span class="math-container" id="1018648" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span>" would be <span class="math-container" id="1018649" visual_id="428138"><math alttext="\mathbf{G}(X)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÜ</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, where <span class="math-container" id="1018650" visual_id="428139"><math alttext="\mathbf{G}\colon\mathscr{Set}\to R\mathscr{mod}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÜ</mi><mo>:</mo><mrow><mrow><mi class="ltx_font_mathscript">ùíÆ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">‚ÑØ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùìâ</mi></mrow><mo>‚Üí</mo><mrow><mi>R</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùìÇ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">‚Ñ¥</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùíπ</mi></mrow></mrow></mrow></semantics></math></span> where <span class="math-container" id="1018651" visual_id="54371"><math alttext="\mathbf{G}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêÜ</mi></semantics></math></span> is the right adjoint of the underlying set functor. </p> <p>However, left adjoints respect colimits; in particular, if <span class="math-container" id="1018652" visual_id="54371"><math alttext="\mathbf{G}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêÜ</mi></semantics></math></span> existed, then <span class="math-container" id="1018653" visual_id="34990"><math alttext="\mathbf{U}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêî</mi></semantics></math></span> would be a left adjoint, and so the underlying set of a direct sum of two modules (which is a coproduct) would necessarily be (bijectable with) the disjoint union of the underlying sets of the modules (as the disjoint union is the coproduct in <span class="math-container" id="1018654" visual_id="44359"><math alttext="\mathscr{Set}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi class="ltx_font_mathscript">ùíÆ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">‚ÑØ</mi><mo>‚Å¢</mo><mi class="ltx_font_mathscript">ùìâ</mi></mrow></semantics></math></span>). This fails in <em>every</em> category of modules, since the direct sum of two trivial modules has underlying set with a single element, but the disjoint union of the underlying sets has two elements. So the underlying set functor cannot have a right adjoint, so there is no "co-free" functor.</p> <p>Alternatively, you can consider the universal property of the free object and see if that can be constructed. A co-free module on a set <span class="math-container" id="1018655" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> would be a module <span class="math-container" id="1018656" visual_id="34624"><math alttext="C(X)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, together with a set-theoretic function <span class="math-container" id="1018657" visual_id="428140"><math alttext="f\colon C(X)\to X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mrow><mi>C</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow><mo>‚Üí</mo><mi>X</mi></mrow></mrow></semantics></math></span> such that for every module <span class="math-container" id="1018658" visual_id="4"><math alttext="M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi></semantics></math></span> and every set-theoretic function <span class="math-container" id="1018659" visual_id="428141"><math alttext="g\colon M\to X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mrow><mi>M</mi><mo>‚Üí</mo><mi>X</mi></mrow></mrow></semantics></math></span>, there exists a unique module homomorphism <span class="math-container" id="1018660" visual_id="428142"><math alttext="\varphi\colon M\to C(X)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œÜ</mi><mo>:</mo><mrow><mi>M</mi><mo>‚Üí</mo><mrow><mi>C</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></semantics></math></span> such that <span class="math-container" id="1018661" visual_id="428143"><math alttext="g=f\circ\varphi" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mrow><mi>f</mi><mo>‚àò</mo><mi>œÜ</mi></mrow></mrow></semantics></math></span>. However, if <span class="math-container" id="1018662" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> has more than one element, then no such object can exist: let <span class="math-container" id="1018663" visual_id="46527"><math alttext="a\in X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>‚àà</mo><mi>X</mi></mrow></semantics></math></span> be different from <span class="math-container" id="1018664" visual_id="16451"><math alttext="f(0)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>; then define <span class="math-container" id="1018665" visual_id="428144"><math alttext="g\colon C(X)\to G" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mrow><mrow><mi>C</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow><mo>‚Üí</mo><mi>G</mi></mrow></mrow></semantics></math></span> to be given by <span class="math-container" id="1018666" visual_id="428145"><math alttext="g(c)=a" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>g</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>a</mi></mrow></semantics></math></span> for all <span class="math-container" id="1018667" visual_id="146"><math alttext="c" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi></semantics></math></span>. Since every module homomorphism must map <span class="math-container" id="1018668" visual_id="2775866"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span> to <span class="math-container" id="1018669" visual_id="2775866"><math alttext="0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn></semantics></math></span>, we would have <span class="math-container" id="1018670" visual_id="428146"><math alttext="a=g(0)=f(\varphi(0))=f(0)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mrow><mi>g</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>œÜ</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, contradicting the choice of <span class="math-container" id="1018671" visual_id="159"><math alttext="a" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi></semantics></math></span>. For <span class="math-container" id="1018672" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> a singleton, <span class="math-container" id="1018673" visual_id="34624"><math alttext="C(X)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> must be the trivial module. For <span class="math-container" id="1018674" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> empty, there is no co-free object. </p> <p>So we cannot dualize "direct summand of free module" into "direct summand of co-free module", because there is no object to play the role of the co-free module. Note that you would need <em>precisely</em> the universal property of the "co-free module" in order to dualize the proof that a direct summand of a free module is projective and vice-versa.</p> <p>An alternative approach might be to think of "free module" as just short-hand for "direct sum of copies of <span class="math-container" id="1018675" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>." If we do that, then the dual of "direct summand of a direct sum of copies of <span class="math-container" id="1018676" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>" would be "direct summand of a direct <em>product</em> of copies of <span class="math-container" id="1018677" visual_id="277"><math alttext="R" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi></semantics></math></span>."</p> <p>But this doesn't work either: for instance, for <span class="math-container" id="1018678" visual_id="3375"><math alttext="\mathbb{Z}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚Ñ§</mi></semantics></math></span>-modules, "injective" is equivalent to "divisible". We would need <span class="math-container" id="1018679" visual_id="856"><math alttext="\mathbb{Q}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚Ñö</mi></semantics></math></span> to be a direct summand a direct product of copies of <span class="math-container" id="1018680" visual_id="3375"><math alttext="\mathbb{Z}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚Ñ§</mi></semantics></math></span>. But <span class="math-container" id="1018681" visual_id="856"><math alttext="\mathbb{Q}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚Ñö</mi></semantics></math></span> cannot even be embedded in a direct product of copies of <span class="math-container" id="1018682" visual_id="3375"><math alttext="\mathbb{Z}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>‚Ñ§</mi></semantics></math></span>, because any  homomorphism <span class="math-container" id="1018683" visual_id="428147"><math alttext="\mathbb{Q}\to\mathbb{Z}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñö</mi><mo>‚Üí</mo><mi>‚Ñ§</mi></mrow></semantics></math></span> is trivial, so any map <span class="math-container" id="1018684" visual_id="428148"><math alttext="\mathbb{Q}\to\prod\mathbb{Z}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñö</mi><mo>‚Üí</mo><mrow><mo largeop="true" movablelimits="false" symmetric="true">‚àè</mo><mi>‚Ñ§</mi></mrow></mrow></semantics></math></span> is necessarily trivial (it is completely determined by the projections, and all the projections are trivial). </p> <p>In short: there is no dual to the proposition that a module is projective if and only if it is a direct summand of a free module.</p> <p>This is just another facet of the fact that the duality between injectives and projectives is not perfect. As I mentioned in comments, for example, every module has an injective hull but not every module has a projective cover, so the duality is not perfect.</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="210796"> Thank you, <span class="math-container" id="2405103">A</span>rturo, for taking the time to respond with such a thoughtful answer.  I am wondering something, though, now that I remembered I had this book.  In Hilton &amp; Stammbach, p. 35, they define an <span class="math-container" id="2405105">A</span>-module to be cofree if it is the direct product of modules Hom_Z(<span class="math-container" id="2405108">A</span>,Q/Z).  Then, they state in Th. 8.4 the dual version of 3 above: I is injective if and only if I is a direct summand in a cofree module.  I am wondering: if this does not have the same interpretation as being in the image of a cofree functor, why call it cofree in the first place? </td></tr><tr><td comment_id="210800"> @dmdmdmdmdmd: They are dualizing yet another way of thinking about free modules (direct sums of Hom sets *into* <span class="math-container" id="1018692" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>); it does not have the dual property of the universal property, nor the dual property of the left adjoint. It's related to thinking about "cogenerators" for a module. I'll take a look at my copy of Anderson-Fuller tomorrow and see if they do something similar. </td></tr><tr><td comment_id="210815"> Oh, I see!  Thanks again for the wonderful explanation! </td></tr><tr><td comment_id="211110"> @dmdmdmdmdmd: Well, Anderson-Fuller don't discuss this version, nor does Lam (though Anderson-Fuller does include the notion of "cogenerators"). Basically, a function from a singleton <span class="math-container" id="1018686" visual_id="8896"><math alttext="\{x\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow></semantics></math></span> to a module <span class="math-container" id="1018687" visual_id="4"><math alttext="M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi></semantics></math></span> is equivalent to an abelian group homomoprhism <span class="math-container" id="1018688" visual_id="428149"><math alttext="\mathbb{Z}\to M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>‚Ñ§</mi><mo>‚Üí</mo><mi>M</mi></mrow></semantics></math></span>; so a function from a set <span class="math-container" id="1018689" visual_id="115"><math alttext="X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi></semantics></math></span> to a module <span class="math-container" id="1018690" visual_id="4"><math alttext="M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi></semantics></math></span> is equivalent to an abelian group homomoprhism <span class="math-container" id="1018691" visual_id="428150"><math alttext="\oplus_{x\in X}\mathbb{Z}\to M" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msub><mo>‚äï</mo><mrow><mi>x</mi><mo>‚àà</mo><mi>X</mi></mrow></msub><mi>‚Ñ§</mi></mrow><mo>‚Üí</mo><mi>M</mi></mrow></semantics></math></span>.<span class="math-container" id="1018685" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>free <span class="math-container" id="1018692" visual_id="188"><math alttext="A" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi></semantics></math></span>-module over <span class="math-container" id="1018693" visual_id="719"><math alttext="K" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi></semantics></math></span> is then equivalent to a direct sum of copies of <span class="math-container" id="1018694" visual_id="428151"><math alttext="\mathrm{Hom}_{\mathbb{Z}}(\mathbb{Z},A)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Hom</mi><mi>‚Ñ§</mi></msub><mo>‚Å¢</mo><mrow><mo stretchy="false">(</mo><mi>‚Ñ§</mi><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>; dualizing gives the direct product in question. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="275522"> Dual notion of free module </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
