<!DOCTYPE html>

<html>
<head>
<title>Calculating $a^n\pmod m$ in the general case</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Calculating <span class="math-container" id="6397695" visual_id="6069655"><math alttext="a^{n}\pmod{m}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> in the general case </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="630134">
<p>It is well known, that </p> <p><span class="math-container" id="6397696" visual_id="6069656"><math alttext="a^{\phi(m)}\equiv 1\pmod{m}," class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><msup><mi>a</mi><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></msup><mo>≡</mo><mrow><mn>1</mn><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>,</mo></mrow></semantics></math></span> </p> <p>if <span class="math-container" id="6397697" visual_id="6069657"><math alttext="\gcd(a,m)=1." class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mrow><mi>gcd</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>1</mn></mrow><mo>.</mo></mrow></semantics></math></span></p> <p>So, <span class="math-container" id="6397698" visual_id="6069655"><math alttext="a^{n}\pmod{m}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> can be calculated by reducing n modulo <span class="math-container" id="6397699" visual_id="40100"><math alttext="\phi(m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>.</p> <p>But, for the tetration modulo <span class="math-container" id="6397700" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span></p> <p><span class="math-container" id="6397701" visual_id="6069658"><math alttext="a\uparrow\uparrow n\pmod{m}," class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>↑</mo><mo>↑</mo><mi>n</mi><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow><mo>,</mo></mrow></semantics></math></span></p> <p>I need the general case, where <span class="math-container" id="6397702" visual_id="159"><math alttext="a" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi></semantics></math></span> and <span class="math-container" id="6397703" visual_id="20"><math alttext="m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi></semantics></math></span> need not to be coprime.</p> <p>Which reduction can I use in this case ?</p> <p>Is there an easier method to calculate the tetration modulo m without using the reductions modulo <span class="math-container" id="6397704" visual_id="6069659"><math alttext="m,\phi(m),\phi(\phi(m))..." class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>,</mo><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo>,</mo><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>⁢</mo><mi mathvariant="normal">…</mi></mrow></mrow></semantics></math></span> ?</p> <p>I tried to write a program in PARI, but I failed because reducing modulo <span class="math-container" id="6397705" visual_id="40100"><math alttext="\phi(m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> does not work, if a and m are not coprime.</p>
</div>
<hr/>
<div id="tags">
<span> number-theory </span><span> modular-arithmetic </span><span> exponentiation </span><span> tetration </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="1328195"> How large are each of the numbers? (approximately) </td></tr><tr><td comment_id="1328198"> If <span class="math-container" id="6397706" visual_id="4817437"><math alttext="gcd(a,m)&gt;1" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>g</mi><mo>⁢</mo><mi>c</mi><mo>⁢</mo><mi>d</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&gt;</mo><mn>1</mn></mrow></semantics></math></span> then <span class="math-container" id="6397707" visual_id="369655"><math alttext="a^{n}\pmod{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> will not be equal to 1 in general. The easiest method of computing exponentiation in that case is to use binary exponentiation (see http://en.wikipedia.org/wiki/Modular_exponentiation) </td></tr><tr><td comment_id="1328199"> m is not large, but without reduction, <span class="math-container" id="6397708" visual_id="2052295"><math alttext="a\uparrow\uparrow n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>↑</mo><mo>↑</mo><mi>n</mi></mrow></semantics></math></span> cannot be calculated, if n&gt;=6 or so. </td></tr><tr><td comment_id="1328204"> At some point, the exponent gets to big, so I must reduce it in a proper way. </td></tr><tr><td comment_id="1328212"> An example problem would be <span class="math-container" id="6397709" visual_id="6069660"><math alttext="7\uparrow\uparrow 6\ (mod\ 97)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>↑</mo><mo>↑</mo><mpadded width="+5pt"><mn>6</mn></mpadded><mrow><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn> 97</mn><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> </td></tr><tr><td comment_id="1328266"> See also http://math.stackexchange.com/questions/587652/doubts-about-a-nested-exponents-modulo-n-homework. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="634395" id="answer">
<blockquote> <p>@sheldon I still do not have a proper algorithm to calculate tetrations modulo m, do you have one?</p> </blockquote> <p>Peter,</p> <p>This is the pari-gp code I have that I think works for all the cases I've tried.  Using this code, I verified that the solution m=34276387, posted in a comment earlier as the smallest prime factor of <span class="math-container" id="6397723" visual_id="6069664"><math alttext="(2\uparrow\uparrow 5+3\uparrow\uparrow 5)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>↑</mo><mo>↑</mo><mn>5</mn><mo>+</mo><mn>3</mn><mo>↑</mo><mo>↑</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> is also a prime factor of  <span class="math-container" id="6397724" visual_id="6069665"><math alttext="(2\uparrow\uparrow 6+3\uparrow\uparrow 6)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>↑</mo><mo>↑</mo><mn>6</mn><mo>+</mo><mn>3</mn><mo>↑</mo><mo>↑</mo><mn>6</mn><mo stretchy="false">)</mo></mrow></semantics></math></span> and  <span class="math-container" id="6397725" visual_id="6069666"><math alttext="(2\uparrow\uparrow 7+3\uparrow\uparrow 7)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>↑</mo><mo>↑</mo><mn>7</mn><mo>+</mo><mn>3</mn><mo>↑</mo><mo>↑</mo><mn>7</mn><mo stretchy="false">)</mo></mrow></semantics></math></span>, and also for all n&gt;7.  Powertower modular arithmetic seems to converge to a value independent of tetration height fairly quickly.  This pari-gp code implements the combination of the Euler phi reduction, and the power2n binary exponentiation function for <span class="math-container" id="6397726" visual_id="6069667"><math alttext="(b\uparrow\uparrow i)\bmod m" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>↑</mo><mo>↑</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>m</mi></mrow></semantics></math></span>.  The key is the combination of the exit conditions, and the <span class="math-container" id="6397727" visual_id="1605154"><math alttext="\log_{2}(m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> repeating pattern starting position, which I got from <a href="https://math.stackexchange.com/questions/631640/lower-and-upper-bounds-for-the-length-of-phi-chains-wanted">the answer to your other recent post</a>.  Then we know, for some integer <span class="math-container" id="6397728" visual_id="6069668"><math alttext="k\lt\log_{2}(m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\lt</mtext></merror><mo>⁢</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>,</p> <p><span class="math-container" id="6397729" visual_id="6069669"><math alttext="b^{k}\equiv b^{k+\phi(m)}\pmod{m}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mi>k</mi></msup><mo>≡</mo><mrow><msup><mi>b</mi><mrow><mi>k</mi><mo>+</mo><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></msup><mspace width="veryverythickmathspace"></mspace><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span></p> <p>This reduces the problem to <span class="math-container" id="6397730" visual_id="6069670"><math alttext="b^{z}\equiv(b\uparrow\uparrow i)\pmod{m}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mi>z</mi></msup><mo>≡</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>↑</mo><mo>↑</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mrow><mo lspace="8.1pt" stretchy="false">(</mo><mrow><mo>mod</mo><mi>m</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> where <span class="math-container" id="6397731" visual_id="6069671"><math alttext="z=(b\uparrow\uparrow(i-1))\bmod\phi(m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>↑</mo><mo>↑</mo><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>-</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>ϕ</mi><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, so long as <span class="math-container" id="6397732" visual_id="6069672"><math alttext="\log_{2}(m)&amp;lt;z&amp;lt;b\uparrow\uparrow i" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>log</mi><mn>2</mn></msub><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><mi mathvariant="normal">&amp;</mi><mi>l</mi><mi>t</mi><mo>;</mo><mi>z</mi><mi mathvariant="normal">&amp;</mi><mi>l</mi><mi>t</mi><mo>;</mo><mi>b</mi><mo>↑</mo><mo>↑</mo><mi>i</mi></mrow></semantics></math></span>.    This requires more work; it would be nice to prove that the exit conditions identified in the pari-gp code are sufficient but for now, working pari-gp code will have to do.  <strong>Code update</strong>, I generalized the boundary condition for <span class="math-container" id="6397733" visual_id="6069673"><math alttext="((b\uparrow\uparrow i)\bmod m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>↑</mo><mo>↑</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></semantics></math></span> where m is a multiple with n&gt;=2, <span class="math-container" id="6397734" visual_id="6069674"><math alttext="n(b\uparrow\uparrow i)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>↑</mo><mo>↑</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, which is a boundary condition for the math equations.  This is fixed in the pari-gp code.  </p> <p>The repeating patterns can be shorter then <span class="math-container" id="6397735" visual_id="40100"><math alttext="\phi(m)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, but that isn't required.  I have another much slower pari-gp program that brute force finds the shortest chains, and the final results match with this version.  Let me know if you find any bugs or missing boundary conditions.  I have tested it fairly exhaustively against the power2n code for prime values of p, with the power tower height=4, and against the slower version for other heights, and for non-prime values of p.  </p> <p>The code can do other interesting stuff, like calculate an arbitrary number of right hand digits of Graham's number, <span class="math-container" id="6397736" visual_id="6069675"><math alttext="(3\uparrow\uparrow 13)\bmod 10^{12}=262464195387" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">(</mo><mn>3</mn><mo>↑</mo><mo>↑</mo><mn>13</mn><mo stretchy="false">)</mo></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><msup><mn>10</mn><mn>12</mn></msup><mo>=</mo><mn>262464195387</mn></mrow></semantics></math></span>, which is stable for i&gt;13.  </p> <pre><code>/* calculates (b^^i) mod m */ reducetower(b,m,i) = {   local(n,rz,log2p);   /* these are the recursion exit conditions */   if ((b%m)==0, return(0));             /* "0" if b divisible by m, or m=1  */   if ((i==2), return(power2n(b,m,b)));  /* if i==2, calculate  (b^b) mod m  */   /* boundary cases for m=3n*(3^^3), just detect m&gt;3^^3, similary for 2^^4  */   /* and similarily for m=2n*(2^^3), just detect m&gt;2^^3                     */   if ((b==2) &amp;&amp; (i==3) &amp;&amp; (m&gt;16),            return (16));   if ((b==2) &amp;&amp; (i==4) &amp;&amp; (m&gt;65536),         return (65536));   if ((b==3) &amp;&amp; (i==3) &amp;&amp; (m&gt;7625597484987), return (7625597484987));   /* theoretically, there is also (b==4) &amp;&amp; (i==3) &amp;&amp; (m&gt;4^^3)              */    log2p=0;   n=eulerphi(m); /* n replaces m in recursion, reducetower(b,n,i-1); */   if (n+1&lt;m, /* if m is not a prime */     log2p=floor(log(m)/log(2)); /* repeating pattern length n guarenteed    */   );   rz = reducetower(b,n,i-1);  /* recursion with i-1, and n replacing m      */   /*  we know there are repeats beginning at or before log2p, so that       */   /*  b^log2p = b^(log2p+n)                                                 */   /*  b^b^z can be replaed with b^(b^z mod n) as long as (b^z mod n)&gt;log2p  */   /*  if b^z&lt;log2p, keep adding (b^z)+n until &gt;= log2p                      */   while ((log2p&gt;0) &amp;&amp; (rz&lt;log2p), rz=rz+n);   rz = power2n(b,m,rz);  /*  (b^rz) mod m  */   if (debugprint,     print("("b"^^"i")%"m"=("b"^(("b"^^"i-1")%"n"))%"m"="rz);   );   return(rz); } power2n(z,m,i) = {   local(t,y);   if (i==0,return(1));   y=z;   t=1;   /* express i in base 2, multiply the subparts of i as they are calculated */   while ((y&lt;&gt;1) &amp;&amp; (i&gt;0),     if ((i%2)==1, t=(t*y)%m;i=i-1);     y=(y*y)%m;     i=i/2;   );   return(t); } </code></pre>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="1337629"> Thanks for your program! I will check some cases. </td></tr><tr><td comment_id="1337915"> Still working on the "proof" of correctness.  It may be awhile... </td></tr><tr><td comment_id="1338522"> Oh, what a pity! So, what about your result of the prime factors of 2^5+3^^5 and 2^^6+3^^6 ? </td></tr><tr><td comment_id="1338547"> sure, which tag is it under? </td></tr><tr><td comment_id="1338586"> I undeleted it. Tags : number-theory, tetration, prime-factors </td></tr><tr><td comment_id="1338810"> I updated the code to fix the boundary condition for (2^^4 mod (2^^4)*2n) which is (2^^4 mod 65536*n), for n=4,6,8,10... For these cases, the algorithm returns zero instead of 2^^4. Similarly, the algorithm also messes up for (3^^3 mod (3^^3)*3n) for example (3^^3 mod 22876792454961). So the simplest solution is that there needs to be a more general dropout, if m&gt;b^^i, then just return(b^^i). I'll eventually modify the pari-gp code. </td></tr><tr><td comment_id="1342784"> @Peter I need to catch u<span class="math-container" id="12480707">p</span> on my modular arithmetic background, which unfortunately isn't very strong, and <span class="math-container" id="12480709">p</span>roving correctness for the boundary conditions I came up with is complicated. </td></tr><tr><td comment_id="3966722"> I installed the software but it warns that it cannot deal directly with more than 80 digits. Anyway, great thanks for this marvellous tool. </td></tr><tr><td comment_id="3966749"> and your function reducetower makes my today question useless, even if it is interesting for itself : [powers of powers of 10 reduction PowerTower](http://math.stackexchange.com/questions/1931658/powers-of-powers-of-10-reduction-powertower) . Thank you so much :) </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="631640"> Lower and upper bounds for the length of phi-chains wanted </td></tr><tr><td post_id="634844"> Stationary prime factor 34276387 , confirmation and generalization wanted. </td></tr><tr><td post_id="1930651"> What can we say about the prime factors of <span class="math-container" id="17897828" visual_id="4975616"><math alttext="A\succsim B\implies P(A)\geq P(B)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>A</mi><mo>⁢</mo><merror class="ltx_ERROR undefined undefined"><mtext>\succsim</mtext></merror><mo>⁢</mo><mi>B</mi></mrow><mo>⟹</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow><mo>≥</mo><mrow><mi>P</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>? </td></tr><tr><td post_id="587652"> Doubts about a nested exponents modulo n (homework) </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
