<!DOCTYPE html>

<html>
<head>
<title>Presicion check for the solution of equations in Numerical Analysis</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Presicion check for the solution of equations in Numerical Analysis </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="1649652">
<p>In order to have precision of 5 decimal points in a Numerical Analysis method for the solution of an equation then:</p> <p><span class="math-container" id="15256235" visual_id="5484700"><math alttext="|x_{n+1}-\rho|\leq\frac{1}{2}\cdot 10^{5}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>ρ</mi></mrow><mo stretchy="false">|</mo></mrow><mo>≤</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⋅</mo><msup><mn>10</mn><mn>5</mn></msup></mrow></mrow></semantics></math></span> </p> <p>where <span class="math-container" id="15256236" visual_id="24510"><math alttext="x_{n+1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></semantics></math></span> the current approximation of the solution and <span class="math-container" id="15256237" visual_id="2419"><math alttext="\rho" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi></semantics></math></span> the actual solution.</p> <p>I am reading though in a textbook that if you want to have precision of 5 decimal points then your condition to stop the method is:</p> <p><span class="math-container" id="15256238" visual_id="5484701"><math alttext="|x_{n+1}-x_{n}|\leq\frac{1}{2}\cdot 10^{5}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><mo stretchy="false">|</mo></mrow><mo>≤</mo><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>⋅</mo><msup><mn>10</mn><mn>5</mn></msup></mrow></mrow></semantics></math></span> </p> <p>where <span class="math-container" id="15256239" visual_id="20070"><math alttext="|1-z|\geq\delta" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mrow><mn>1</mn><mo>-</mo><mi>z</mi></mrow><mo stretchy="false">|</mo></mrow><mo>≥</mo><mi>δ</mi></mrow></semantics></math></span> is approximation of the solution in the previous step.</p> <p>What I am thinking is that if the method is indeed converging to the actual solution then you will find the correct approximation using the second check, but if the method converges in a false point (i.e. the method doesn't work correctly for a number of reasons) then you will have found a wrong approximation (but hey you will at least have it with a precision of 5 decimal points). </p> <p>Isn't this right? How can the second check be used generally? </p>
</div>
<hr/>
<div id="tags">
<span> numerical-methods </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
<tr><td comment_id="3364622"> When you finish the loop you need to use the value you obtained to check that it produces the required accuracy by substituting it in the original function. If it produces the correct result, then it is an acceptable approximation of the root. </td></tr><tr><td comment_id="3365186"> @NoChance This is kind of a trial and error sometimes. Isn't any rule or a reason why this is correct? </td></tr><tr><td comment_id="3365343"> I really don't know. To a great extent, the result depends on the function in question as well as your choice of  how to express <span class="math-container" id="15256240" visual_id="155031"><math alttext="x_{n+1}=g(x_{n})" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>. </td></tr><tr><td comment_id="3366856"> @NoChance Don't worry your comment helped me because from what I see is that we are always trying to find complex answers in easy questions so your input is really useful when you have to check the results of a method. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="1650403" id="answer">
<p>Consider the problem of solving the equation <span class="math-container" id="15256241" visual_id="2020"><math alttext="f(x)=0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></semantics></math></span>, where <span class="math-container" id="15256242" visual_id="3106"><math alttext="f:\mathbb{R}\rightarrow\mathbb{R}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>ℝ</mi><mo>→</mo><mi>ℝ</mi></mrow></mrow></semantics></math></span> is at least continuous.</p> <p>In general, it root finder should monitor both the distance between successive iterates, i.e.  \begin{equation} \delta_n = |x_n-x_{n+1}| \end{equation} as well as the absolute value of the residual, i.e.  \begin{equation} \epsilon_n = |f(x_n)| \end{equation} and terminate if one of these numbers drops below a user defined threshold. Some applications do not require a small error and the user is happy if the residual is small. </p> <p>If the iteration is converging to a root, then both <span class="math-container" id="15256243" visual_id="67884"><math alttext="\delta_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>δ</mi><mi>n</mi></msub></semantics></math></span> and <span class="math-container" id="15256244" visual_id="13368"><math alttext="\epsilon_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>n</mi></msub></semantics></math></span> will eventually be small.</p> <p>However, and this is critical, the reverse is <em>not</em> true! Given thresholds <span class="math-container" id="15256245" visual_id="41"><math alttext="\delta" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi></semantics></math></span> and <span class="math-container" id="15256246" visual_id="46"><math alttext="\epsilon" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi></semantics></math></span> it is possible to construct a function <span class="math-container" id="15256247" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> which has a well defined zero for which Newton's method diverges and satisfies  \begin{equation} \delta_n \leq \delta \quad\text{and}\quad \epsilon_n &lt; \epsilon \end{equation}  for all sufficiently large <span class="math-container" id="15256248" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>. A specific example is the function  \begin{equation} f_{\lambda}(x) = p(x) \exp(-\lambda x) \end{equation} where <span class="math-container" id="15256249" visual_id="74"><math alttext="p" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi></semantics></math></span> is a real polynomial with a single root <span class="math-container" id="15256250" visual_id="180"><math alttext="r" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi></semantics></math></span> and <span class="math-container" id="15256251" visual_id="21854"><math alttext="\lambda&amp;gt;0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>λ</mi><mo>&gt;</mo></mrow><mn>0</mn></mrow></semantics></math></span> is a real number to be determined shortly. Obviously, we would be mad not to focus on <span class="math-container" id="15256252" visual_id="76"><math alttext="p(x)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span>, but while it is easy for a human to make that determination it is hard to infuse a machine with this ability. Away from the root <span class="math-container" id="15256253" visual_id="180"><math alttext="r" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi></semantics></math></span>, Newton's method takes the form \begin{multline} x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} = x_n - \frac{f(x_n)}{p'(x_n)e^{-\lambda x_n} - \lambda f(x_n)} \\ = x_n - \frac{1}{p'(x_n)/p(x) - \lambda} \approx x_n + \frac{1}{\lambda}, \end{multline} because <span class="math-container" id="15256254" visual_id="5484702"><math alttext="\frac{p^{\prime}(x)}{p(x)}\rightarrow 0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msup><mi>p</mi><mo>′</mo></msup><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mrow><mi>p</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mfrac><mo>→</mo><mn>0</mn></mrow></semantics></math></span> as <span class="math-container" id="15256255" visual_id="2326"><math alttext="x\rightarrow\infty" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></semantics></math></span>. We conclude that if the user has picked an initial guess sufficient far to the right of the the root,  \begin{equation} r \ll x_0 \end{equation} then not only will we continue to move away from the root as \begin{equation} r &lt; x_n &lt; x_{n+1} \sim x_n + \frac{1}{\lambda} \end{equation} but we will have  \begin{equation} \delta_n &lt; \delta \end{equation} provided <span class="math-container" id="15256256" visual_id="5484703"><math alttext="\lambda&amp;gt;\frac{1}{\delta}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>λ</mi><mo>&gt;</mo></mrow><mfrac><mn>1</mn><mi>δ</mi></mfrac></mrow></semantics></math></span>. Moreover, since <span class="math-container" id="15256257" visual_id="138831"><math alttext="x_{n}\rightarrow\infty" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></semantics></math></span> we will eventually have \begin{equation} \epsilon_n &lt; \epsilon \end{equation} In short, if a routine is only monitoring the distance between successive iterates and the size of the residual, then it can be defeated by a sufficiently clumsy user. An alert user will examine the entire sequence of approximations and discover that it is not converging towards a real number.</p> <p>A robust routine will instead strive to maintain and shrink a bracket around the root, i.e. an interval <span class="math-container" id="15256258" visual_id="3186"><math alttext="[a,b]" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow></semantics></math></span> for which <span class="math-container" id="15256259" visual_id="12920"><math alttext="f(a)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> and <span class="math-container" id="15256260" visual_id="13902"><math alttext="f(b)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> have different sign. As input, it should accept an initial bracket as well as handler to a function which computes not only a good approximation <span class="math-container" id="15256261" visual_id="53166"><math alttext="\hat{y}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></semantics></math></span> of <span class="math-container" id="15256262" visual_id="2468"><math alttext="y=f(x)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, but also an error bound <span class="math-container" id="15256263" visual_id="5484704"><math alttext="|y-\hat{y}|\leq mu" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mrow><mi>y</mi><mo>-</mo><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></mrow><mo stretchy="false">|</mo></mrow><mo>≤</mo><mrow><mi>m</mi><mo>⁢</mo><mi>u</mi></mrow></mrow></semantics></math></span>, where <span class="math-container" id="15256264" visual_id="3110998"><math alttext="m=m(y)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mrow><mi>m</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span> is an integer and <span class="math-container" id="15256265" visual_id="506"><math alttext="u" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi></semantics></math></span> is the unit round off error. There is no point in continuing past the point where <span class="math-container" id="15256266" visual_id="5484705"><math alttext="|\hat{y}|\leq|y-\hat{y}|" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">|</mo><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover><mo stretchy="false">|</mo></mrow><mo>≤</mo><mrow><mo stretchy="false">|</mo><mrow><mi>y</mi><mo>-</mo><mover accent="true"><mi>y</mi><mo stretchy="false">^</mo></mover></mrow><mo stretchy="false">|</mo></mrow></mrow></semantics></math></span> as the true value of might as well be zero. Computing an error bound allows the routine to make that determination. </p> <p>If you successfully shrink the length of the bracket down to <span class="math-container" id="15256267" visual_id="1305"><math alttext="10^{-5}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>10</mn><mrow><mo>-</mo><mn>5</mn></mrow></msup></semantics></math></span>, then the midpoint, i.e. <span class="math-container" id="15256268" visual_id="5484706"><math alttext="\mu=a+\frac{b-a}{2}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mrow><mi>a</mi><mo>+</mo><mfrac><mrow><mi>b</mi><mo>-</mo><mi>a</mi></mrow><mn>2</mn></mfrac></mrow></mrow></semantics></math></span> will approximate the root with 5 decimal figures.</p> <p>A good routine can be written by merging the bisection method (bracket) with the secant method (fast local convergence). Error bounds are harder to come by but can be established using the method of running error bounds. N. Higham derives a running error bound for polynomials discusses in his book "Accuracy and Stability of Numerical algorithms".</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="3366880"> Thank you for your well-written answer. If I understand correctly then you are saying that if a method is proven to converge to a root then both checks are good but if not then the distance between successive iterations may grow bigger every time? One more thing that I don't understand is "If <span class="math-container" id="15256269" visual_id="21893"><math alttext="\lambda&gt;0" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>&gt;</mo><mn>0</mn></mrow></semantics></math></span>, then not only are we marching further away from the root, but if <span class="math-container" id="15256273" visual_id="664"><math alttext="\lambda" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi></semantics></math></span> is large, then <span class="math-container" id="15256271" visual_id="67884"><math alttext="\delta_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>δ</mi><mi>n</mi></msub></semantics></math></span> is small and given enough time <span class="math-container" id="15256274" visual_id="13368"><math alttext="\epsilon_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>n</mi></msub></semantics></math></span> will also be small." If <span class="math-container" id="15256273" visual_id="664"><math alttext="\lambda" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi></semantics></math></span> is growing how can <span class="math-container" id="15256274" visual_id="13368"><math alttext="\epsilon_{n}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ϵ</mi><mi>n</mi></msub></semantics></math></span> become small? </td></tr><tr><td comment_id="3367149"> @Adam: I thought it over and decided to extend a part of the answer. I think that it is clearer now and that it should take care of your questions. Otherwise, let me know. </td></tr><tr><td comment_id="3367269"> Your answer is great.  Thank you very much for your explanation. You added even more than I asked for. </td></tr><tr><td comment_id="3367292"> @Adam: Thank you very much. Answering questions and modifying the explanation to clarify key points helps my own understanding. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
