<!DOCTYPE html>

<html>
<head>
<title>Surjectivity of Composite Functions</title>
<link href="https://cdn.sstatic.net/Shared/stacks.css?v=079c5e1603be" rel="stylesheet" type="text/css"/>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js" type="text/javascript"> </script>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap-theme.min.css" rel="stylesheet"/>
<style>
        .row {
          display: block;
          margin-left: auto;
          margin-right: auto;
          width:50%;
        }
        tr {
          border:1px solid lightgrey;
        }
        </style>
</head>
<body>
<div>
<div class="row" id="question-title">
<h1> Surjectivity of Composite Functions </h1>
<hr/>
</div>
<div class="row">
<div class="question">
<div id="question" question_id="745037">
<p>The question I'm asking might be rather simple, but I couldn't find relevant information (maybe it's too trivial?). Here's the question that baffled me.</p> <blockquote> <p>Let <span class="math-container" id="7395809" visual_id="2889"><math alttext="f:X\rightarrow Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow></mrow></semantics></math></span> and <span class="math-container" id="7395810" visual_id="294672"><math alttext="g:Y\rightarrow Z" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mrow><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow></mrow></semantics></math></span> functions. If g and <span class="math-container" id="7395811" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span> are invertible, then is f also invertible?</p> </blockquote> <p>Now, the reason I'm confused is that I'm currently learning set theory. I'm using the textbook "Introduction to Set Theory" by Karel Harbacek and Thomas Jech. In the book, the composite function is defined as follows:</p> <blockquote> <p><span class="math-container" id="7395812" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span>={(x, y)| <span class="math-container" id="7395813" visual_id="7300"><math alttext="\exists" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∃</mo></semantics></math></span>z(f(x)=z <span class="math-container" id="7395814" visual_id="23170"><math alttext="\land" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo></semantics></math></span> g(z)=y)} where dom(<span class="math-container" id="7395815" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span>)=domf <span class="math-container" id="7395816" visual_id="1610"><math alttext="\cap" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∩</mo></semantics></math></span><span class="math-container" id="7395817" visual_id="2"><math alttext="f^{-1}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup></semantics></math></span>[domg]</p> </blockquote> <p>Notice that we only need the intermediate <span class="math-container" id="7395818" visual_id="44"><math alttext="z" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi></semantics></math></span> to find the elements of the composite function, and only the domain is defined. Now, consider the case where f(1)=1 and g(k)=k for all <span class="math-container" id="7395819" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span>, where <span class="math-container" id="7395820" visual_id="83"><math alttext="k" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi></semantics></math></span> is equal or less than a certain natural number <span class="math-container" id="7395821" visual_id="177"><math alttext="n" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi></semantics></math></span>.</p> <p>In this case, clearly <span class="math-container" id="7395822" visual_id="627"><math alttext="g" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi></semantics></math></span> is bijective, hence invertible. The problem is the composite function. Since we defined only the domain of a composite function, the domain of the composite function in this case is {1} and the range is {1}. </p> <p>Now, should we regard this range as the comain(surjective) so the composite function is invertible? Or, should we say the codomain of the composite function is <span class="math-container" id="7395823" visual_id="388"><math alttext="Z" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi></semantics></math></span>, the codomain of g? This ambiguousity arose because the definition of the composite function seems somewhat incomplete. </p> <p><em>My second question</em> is, what if the problem didn't specify all the domains and codomains of each function? Then would be the conclusion different from the first case?</p> <p><em>Lastly,</em> I've heard from one of my fellows that in some textbook the domain of the composite function is defined as just plainly, <span class="math-container" id="7395824" visual_id="1051543"><math alttext="domf" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>⁢</mo><mi>o</mi><mo>⁢</mo><mi>m</mi><mo>⁢</mo><mi>f</mi></mrow></semantics></math></span>. What made all the authors to make different definitions to such an important concept! I'm being confused!</p> <p>Thanks in advance. </p>
</div>
<hr/>
<div id="tags">
<span> elementary-set-theory </span><span> functions </span><span> function-and-relation-composition </span>
</div>
<hr/>
<div id="question-comments">
<table>
<tbody>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div class="answer">
<div answer_id="745101" id="answer">
<p>Your <em>set-theoretic</em> definition of <span class="math-container" id="7395825" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span> is more general than the usual definition. Usually, if one write <span class="math-container" id="7395826" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span>, that carries the implicit assumption that <span class="math-container" id="7395827" visual_id="47509"><math alttext="g(f(x))" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> is defined for <em>every</em> <span class="math-container" id="7395828" visual_id="1482143"><math alttext="x\in\textrm{dom }f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mrow><mtext>dom </mtext><mo>⁢</mo><mi>f</mi></mrow></mrow></semantics></math></span>. In other words, one assumes that <span class="math-container" id="7395829" visual_id="4501417"><math alttext="f(\textrm{dom }f)\subset\textrm{dom g}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mtext>dom </mtext><mo>⁢</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>⊂</mo><mtext>dom g</mtext></mrow></semantics></math></span>. Your set-theoretic definition, OTOH, simply removes those <span class="math-container" id="7395830" visual_id="67"><math alttext="x" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi></semantics></math></span> for which <span class="math-container" id="7395831" visual_id="4501418"><math alttext="f(x)\notin\textrm{dom g}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>∉</mo><mtext>dom g</mtext></mrow></semantics></math></span> from the domain of <span class="math-container" id="7395832" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span>.</p> <p>There's also an ambiguitiy in what <em>invertible</em> means here. If you take <em>invertible</em> to be a synonym for <em>bijective</em>, then for <span class="math-container" id="7395833" visual_id="2889"><math alttext="f\,:X\to Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mpadded width="+1.7pt"><mi>f</mi></mpadded><mo>:</mo><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow></mrow></semantics></math></span> to be invertible, it in particular needs to be surjective, i.e. <span class="math-container" id="7395834" visual_id="4501419"><math alttext="f(\textrm{dom f})=Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mtext>dom f</mtext><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>Y</mi></mrow></semantics></math></span>. In that case, there's a <span class="math-container" id="7395835" visual_id="23924"><math alttext="g\,:\,Y\to X" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mpadded width="+1.7pt"><mi>g</mi></mpadded><mo rspace="4.2pt">:</mo><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow></mrow></semantics></math></span> such that <span class="math-container" id="7395836" visual_id="824937"><math alttext="g\circ f=\textrm{id}_{X}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><mo>=</mo><msub><mtext>id</mtext><mi>X</mi></msub></mrow></semantics></math></span> and <span class="math-container" id="7395837" visual_id="824939"><math alttext="f\circ g=\textrm{id}_{Y}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><mo>=</mo><msub><mtext>id</mtext><mi>Y</mi></msub></mrow></semantics></math></span>. But people will, quite often, call an <span class="math-container" id="7395838" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> <em>invertible</em> if it is only injective, i.e. if <span class="math-container" id="7395839" visual_id="4501420"><math alttext="f(\textrm{dom }f)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mtext>dom </mtext><mo>⁢</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> is a proper subset of <span class="math-container" id="7395840" visual_id="375"><math alttext="Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi></semantics></math></span>. You can then still find a <span class="math-container" id="7395841" visual_id="627"><math alttext="g" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi></semantics></math></span> with <span class="math-container" id="7395842" visual_id="824937"><math alttext="g\circ f=\textrm{id}_{X}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><mo>=</mo><msub><mtext>id</mtext><mi>X</mi></msub></mrow></semantics></math></span>, but you won't have that <span class="math-container" id="7395843" visual_id="824939"><math alttext="f\circ g=\textrm{id}_{Y}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><mo>=</mo><msub><mtext>id</mtext><mi>Y</mi></msub></mrow></semantics></math></span>. Such a <span class="math-container" id="7395844" visual_id="627"><math alttext="g" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi></semantics></math></span> is called a <em>left-inverse</em> of <span class="math-container" id="7395845" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span>. You can always <em>make</em> such an <span class="math-container" id="7395846" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> bijective by restricting it's codomain to it's actual range, i.e. redefining it as <span class="math-container" id="7395847" visual_id="4501421"><math alttext="f\,:\textrm{dom }f\to f(\textrm{dom }f)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mpadded width="+1.7pt"><mi>f</mi></mpadded><mo>:</mo><mrow><mrow><mtext>dom </mtext><mo>⁢</mo><mi>f</mi></mrow><mo>→</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mtext>dom </mtext><mo>⁢</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></semantics></math></span>. Since the set-theoretic definition of a function doesn't <em>explicitly</em> specify the domain and codomain, these two <span class="math-container" id="7395848" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> are, set-theoretically, the <em>same</em> function - they both contain, after all, the <em>same</em> pairs of values. In other words, saying "<span class="math-container" id="7395849" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> is surjective" doesn't make much sense from a set-theoretical viewpoint, and so interpreting <em>invertible</em> to mean <em>injective</em> is a sensible way to go.</p> <p>Let's now assume that <em>invertible</em> refers to the weaker definition here, i.e. simply means <em>injective</em>. Then, if <span class="math-container" id="7395850" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span> is injective, <span class="math-container" id="7395851" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> must be injective too - if <span class="math-container" id="7395852" visual_id="1273185"><math alttext="f(x)=f(y)=z" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>z</mi></mrow></semantics></math></span> then surely <span class="math-container" id="7395853" visual_id="4501422"><math alttext="g(f(x))=g(z)=g(f(y))" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, contradicting the injectivity of <span class="math-container" id="7395854" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span>. So in that case, you don't even need to assume that <span class="math-container" id="7395855" visual_id="627"><math alttext="g" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi></semantics></math></span> is invertible. But you need to be carefull if you use your set-theoretic definition of <span class="math-container" id="7395856" visual_id="23011"><math alttext="\circ" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∘</mo></semantics></math></span>. It might be that <span class="math-container" id="7395857" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> is injective if restricted <span class="math-container" id="7395858" visual_id="4501423"><math alttext="x\in\textrm{dom g}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mtext>dom g</mtext></mrow></semantics></math></span>, but might not be injective on it's whole domain. So to be safe, you strictly speaking can only say that</p> <blockquote> <p>If <span class="math-container" id="7395859" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span> is injective, then <span class="math-container" id="7395860" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> is injective on <span class="math-container" id="7395861" visual_id="4501424"><math alttext="\{x\in\textrm{dom f}\,:\,f(x)\in\textrm{dom }g\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mrow><mi>x</mi><mo>∈</mo><mpadded width="+1.7pt"><mtext>dom f</mtext></mpadded></mrow><mo rspace="4.2pt">:</mo><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>∈</mo><mrow><mtext>dom </mtext><mo>⁢</mo><mi>g</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></semantics></math></span>.</p> </blockquote> <p>If, OTOH, <em>invertible</em> means bijective, then <span class="math-container" id="7395862" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> is clearly bijective, since obviously <span class="math-container" id="7395863" visual_id="3457284"><math alttext="f=g^{-1}\circ(g\circ f)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mrow><msup><mi>g</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>∘</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></semantics></math></span>, and the concatenation of bijective functions is bijective. You have that <span class="math-container" id="7395864" visual_id="4501425"><math alttext="f^{-1}=(g\circ f)^{-1}\circ g" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>=</mo><mrow><msup><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo>∘</mo><mi>g</mi></mrow></mrow></semantics></math></span> in this case.</p>
</div>
<hr/>
<div id="answer-comments">
<table>
<tbody>
<tr><td comment_id="1552764"> Your answer made me breathe again... There are still several questions. (1) Set theory is the foundation of mathematics, and why are there different definitions to the same concept? I think it should be forbidden, seriously. (2) Indeed, we have same functions when two functions have the same domain and the range of them are the same. Then what is good for codomain? Couldn't we just let f:X-&gt;Y denote a function whose range is Y? </td></tr><tr><td comment_id="1552792"> (3) So for the example I've shown, where f(1)=1 and g(k)=k and domf={1}, can we call g∘f bijective? It's so confusing since the left inverse obviously exists but it's not clear what codomain of g∘f should be. I mean, what is the meaning of 'g∘f is bijective'? As for the title, what is the surjectivity of the composite function? </td></tr><tr><td comment_id="1552899"> @TaxxiDriver <span class="math-container" id="7395865" visual_id="8087"><math alttext="g\circ f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow></semantics></math></span> is bijective as a function <span class="math-container" id="7395866" visual_id="3145936"><math alttext="\{1\}\to\{1\}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">{</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><mo>→</mo><mrow><mo stretchy="false">{</mo><mn>1</mn><mo stretchy="false">}</mo></mrow></mrow></semantics></math></span>. It's not bijective as a function <span class="math-container" id="7395867" visual_id="4501426"><math alttext="\{1\}\to\mathbb{N}" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="false">{</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><mo>→</mo><mi>ℕ</mi></mrow></semantics></math></span>, because it's not surjective. It's trivially injective (every function whose domain has cardinality 1 is obviously injective), so it has a left-inverse. </td></tr><tr><td comment_id="1552921"> @TaxxiDriver Viewing set-theory as *the* foundation of mathematics is slightly troublesome, as this example shows. View it as *one* possible foundation, and keep in mind that there are *different* ways to map various concepts to the language of set theory. For example, you *could* defined a function as a triple <span class="math-container" id="7395868" visual_id="4501427"><math alttext="f=(X,Y,F)" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo>,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow></mrow></semantics></math></span> where <span class="math-container" id="7395869" visual_id="3398131"><math alttext="F\subset X\times Y" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊂</mo><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow></mrow></semantics></math></span>, i.e. make the codomain explicit. For most set-theoretic purposes, however, that's less convenient than the usual definition as a set of pairs. </td></tr><tr><td comment_id="1552974"> @TaxxiDriver You might also want to read my answer [here](http://math.stackexchange.com/questions/709925/should-an-undergrad-accept-that-some-things-dont-make-sense-or-study-the-found/709954#709954), it deals with a similar issue where one concept (real and complex numbers, in that case) can be mapped in different ways to the language of set-theory </td></tr><tr><td comment_id="1554288"> I got it, thanks. But I still think there should and could be less ambiguousity. I mean, in my definition, I can form a composite function even if the codomain of <span class="math-container" id="7395870" visual_id="1"><math alttext="f" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi></semantics></math></span> and domain of <span class="math-container" id="7395871" visual_id="627"><math alttext="g" class="ltx_Math" display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi></semantics></math></span> aren't the same. That's a HUGE difference from the 'general' point of view where it cannot be done. But from your answers, I've realized again that this is all about a 'language' to express certain concepts and I should rather see the beneath of it. Maybe Incompleteness Theorem of Godel might hold for all other axiomatic languages? Who knows? Thanks, anyway. </td></tr>
</tbody>
</table>
</div>
</div>
<hr style="border-top: 3px double #8c8b8b"/>
</div>
<div class="row">
<div id="duplicate">
<table>
<tbody>
</tbody>
</table>
</div>
<hr/>
<div id="related">
<table>
<tbody>
<tr><td post_id="709925"> Should an undergrad accept that some things don't make sense, or study the foundation of mathematics to resolve this? </td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
